<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>lwip 源码分析 | TenonOS-unikraft-learning</title>
  <meta name="description" content="lwiplwip 简介LwIP全名：Light weight IP，意思是轻量化的TCP&#x2F;IP协议，是瑞典计算机科学院(SICS)的Adam Dunkels 开发的一个小型开源的TCP&#x2F;IP协议栈。LwIP的设计初衷是：用少量的资源消耗实现一个较为完整的TCP&#x2F;IP协议栈，其中“完整”主要指的是TCP协议的完整性，实现的重点是在保持TCP协议主要功能的基础上减少对RAM 的占用。此外LwIP既可以">
<meta property="og:type" content="article">
<meta property="og:title" content="lwip 源码分析">
<meta property="og:url" content="http://example.com/2022/10/30/lwip/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="lwiplwip 简介LwIP全名：Light weight IP，意思是轻量化的TCP&#x2F;IP协议，是瑞典计算机科学院(SICS)的Adam Dunkels 开发的一个小型开源的TCP&#x2F;IP协议栈。LwIP的设计初衷是：用少量的资源消耗实现一个较为完整的TCP&#x2F;IP协议栈，其中“完整”主要指的是TCP协议的完整性，实现的重点是在保持TCP协议主要功能的基础上减少对RAM 的占用。此外LwIP既可以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/unikraft-liblwip/lwip_init.svg">
<meta property="og:image" content="http://example.com/images/unikraft-liblwip/unikraft-lwip.svg">
<meta property="og:image" content="http://example.com/images/unikraft-liblwip/_netbuf_pbuf.png">
<meta property="og:image" content="http://example.com/images/unikraft-liblwip/input_stream.svg">
<meta property="og:image" content="http://example.com/images/unikraft-liblwip/output_stream.svg">
<meta property="article:published_time" content="2022-10-30T13:44:48.824Z">
<meta property="article:modified_time" content="2022-10-30T13:41:09.446Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="unikraft-网络通信">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/unikraft-liblwip/lwip_init.svg">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2022/10/30/lwip/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/TenonOS" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">TenonOS</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">unikraft-learning</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Zhejiang, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/TenonOS" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-basic-knowledge/">unikraft-basic_knowledge</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-bus/">unikraft-bus</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-liblwip/">unikraft-liblwip</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-libs-9pfs/">unikraft-libs-9pfs</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-libs-futex/">unikraft-libs-futex</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-libs-process/">unikraft-libs-process</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-libs-ukalloc/">unikraft-libs-ukalloc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-libs-ukallocbbuddy/">unikraft-libs-ukallocbbuddy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-libs-vfscore/">unikraft-libs-vfscore</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-libs-%E5%AF%BC%E8%A7%88/">unikraft-libs-导览</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-netdev/">unikraft-netdev</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-syscall/">unikraft-syscall</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-thread/">unikraft-thread</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-uknetdev/">unikraft-uknetdev</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unikraft-virtio/">unikraft-virtio</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="tag">Linux系统调用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-bus/" rel="tag">unikraft-bus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-futex/" rel="tag">unikraft-futex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-netdev/" rel="tag">unikraft-netdev</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-process/" rel="tag">unikraft-process</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-thread/" rel="tag">unikraft-thread</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-virtio/" rel="tag">unikraft-virtio</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">unikraft-内存管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" rel="tag">unikraft-函数调用</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" rel="tag">unikraft-文件系统</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="tag">unikraft-线程管理</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unikraft-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">unikraft-网络通信</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" style="font-size: 13px;">Linux系统调用</a> <a href="/tags/unikraft-bus/" style="font-size: 13px;">unikraft-bus</a> <a href="/tags/unikraft-futex/" style="font-size: 13px;">unikraft-futex</a> <a href="/tags/unikraft-netdev/" style="font-size: 13px;">unikraft-netdev</a> <a href="/tags/unikraft-process/" style="font-size: 13px;">unikraft-process</a> <a href="/tags/unikraft-thread/" style="font-size: 13.33px;">unikraft-thread</a> <a href="/tags/unikraft-virtio/" style="font-size: 14px;">unikraft-virtio</a> <a href="/tags/unikraft-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 13.67px;">unikraft-内存管理</a> <a href="/tags/unikraft-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" style="font-size: 13.33px;">unikraft-函数调用</a> <a href="/tags/unikraft-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" style="font-size: 14px;">unikraft-文件系统</a> <a href="/tags/unikraft-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" style="font-size: 13.33px;">unikraft-线程管理</a> <a href="/tags/unikraft-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" style="font-size: 13.33px;">unikraft-网络通信</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">19</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/unikraft-syscall/">unikraft-syscall</a>
              </p>
              <p class="item-title">
                <a href="/2022/11/07/Unikraft%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" class="title">Unikraft函数调用</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-07T03:21:35.438Z" itemprop="datePublished">2022-11-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/unikraft-syscall/">unikraft-syscall</a>
              </p>
              <p class="item-title">
                <a href="/2022/11/07/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" class="title">Linux系统调用</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-07T03:21:35.401Z" itemprop="datePublished">2022-11-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/unikraft-basic-knowledge/">unikraft-basic_knowledge</a>
              </p>
              <p class="item-title">
                <a href="/2022/11/07/kvm%20qemu%20virtio%E4%B8%80%E4%BA%9B%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9F%A5%E8%AF%86/" class="title">kvm qemu virtio一些虚拟化知识</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-07T03:21:35.399Z" itemprop="datePublished">2022-11-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/unikraft-virtio/">unikraft-virtio</a>
              </p>
              <p class="item-title">
                <a href="/2022/11/07/9pfs%20kvm%20qemu%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B/" class="title">9pfs kvm qemu源码流程</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-07T03:21:35.388Z" itemprop="datePublished">2022-11-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/unikraft-liblwip/">unikraft-liblwip</a>
              </p>
              <p class="item-title">
                <a href="/2022/10/30/lwip/" class="title">lwip 源码分析</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-30T13:44:48.824Z" itemprop="datePublished">2022-10-30</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lwip"><span class="toc-number">1.</span> <span class="toc-text">lwip</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lwip-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">lwip 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lwip-%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">lwip 的三种编程接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unikraft-%E4%B8%8B%E7%9A%84-lwip"><span class="toc-number">2.</span> <span class="toc-text">unikraft 下的 lwip</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#liblwip-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">liblwip 初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lwip-%E4%B8%8E-unikraft-%E7%BB%93%E6%9E%84%E6%98%A0%E5%B0%84"><span class="toc-number">2.2.</span> <span class="toc-text">lwip 与 unikraft 结构映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#input-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">input 执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#output-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">output 执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92"><span class="toc-number">2.5.</span> <span class="toc-text">与用户交互</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-lwip" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      lwip 源码分析
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/10/30/lwip/" class="article-date">
	  <time datetime="2022-10-30T13:44:48.824Z" itemprop="datePublished">2022-10-30</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/unikraft-liblwip/">unikraft-liblwip</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/unikraft-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">unikraft-网络通信</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/10/30/lwip/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="lwip"><a href="#lwip" class="headerlink" title="lwip"></a>lwip</h1><h2 id="lwip-简介"><a href="#lwip-简介" class="headerlink" title="lwip 简介"></a>lwip 简介</h2><p>LwIP全名：Light weight IP，意思是轻量化的TCP/IP协议，是瑞典计算机科学院(SICS)的Adam Dunkels 开发的一个小型开源的TCP/IP协议栈。LwIP的设计初衷是：用少量的资源消耗实现一个较为完整的TCP/IP协议栈，其中“完整”主要指的是TCP协议的完整性，实现的重点是在保持TCP协议主要功能的基础上减少对RAM 的占用。此外LwIP既可以移植到操作系统上运行，也可以在无操作系统的情况下独立运行。</p>
<h2 id="lwip-的三种编程接口"><a href="#lwip-的三种编程接口" class="headerlink" title="lwip 的三种编程接口"></a>lwip 的三种编程接口</h2><p>LwIP提供了三种编程接口，分别为RAW/Callback API、NETCONN API、SOCKET API。它们的易用性从左到右依次提高，而执行效率从左到右依次降低。下面对这三种 API 进行介绍：</p>
<ol>
<li>RAW/Callback API<br>RAW/Callback API是LwIP的一大特色，在没有操作系统支持的裸机环境中，只能使用这种API进行开发，同时这种API也可以用在操作系统环境中。</li>
<li>NETCONN API<br>在操作系统环境中，可以使用NETCONN API或者Socket API进行网络应用程序的开发。NETCONN API是基于操作系统的IPC机制（即信号量和邮箱机制）实现的，它的设计将LwIP内核代码和网络应用程序分离成了独立的线程。如此一来，LwIP内核线程就只负责数据包的TCP/IP封装和拆封，而不用进行数据的应用层处理，大大提高了系统对网络数据包的处理效率。</li>
<li>SOCKET API<br>Socket，即套接字，它对网络连接进行了高级的抽象，使得用户可以像操作文件一样操作网络连接。它十分易用，许多网络开发人员最早接触的就是Socket编程，Socket已经成为了网络编程的标准。在不同的系统中，运行着不同的TCP/IP协议，但是只要它实现了Socket的接口，那么用Socket编写的网络应用程序就能在其中运行。可见用Socket编写的网络应用程序具有很好的可移植性。</li>
</ol>
<h1 id="unikraft-下的-lwip"><a href="#unikraft-下的-lwip" class="headerlink" title="unikraft 下的 lwip"></a>unikraft 下的 lwip</h1><p>通过上文的描述，我们可以发现 unikraft 内部使用了两种 API 来接入 lwip，uknetdev 部分对应 NETCONN API，posix_socket 部分对应 socket API。</p>
<p>在 LwIP 中，用户代码与协议栈内部之间是通过邮箱进行数据的交互的，邮箱本质上就是一个指向数据的指针，API 将指针传递给内核，内核通过这个指针访问数据，然后去处理，反之内核将数据传递给用户代码也是通过邮箱将一个指针进行传递。</p>
<p>在操作系统环境下，LwIP 会作为一个线程运行，线程的名字叫 tcpip_thread，在初始化 LwIP的时候，内核就会自动创建这个线程，并且在线程运行的时候阻塞在邮箱上，等待数据进行处理，这个邮箱数据的来源可能在底层网卡接收到的数据或者上层应用程序的数据，总之，tcpip_thread 线程在获取到邮箱中的数据时候，就会退出阻塞态，去处理数据，在处理完毕数据后又进入阻塞态中等待数据的到来，如此反复。</p>
<p>信号量与互斥量的实现为内核提供同步与互斥的机制，比如当用户想要发送一个数据的时候，就会调用上层 API 接口，API 接口就会去先发送一个数据给内核去处理，然后尝试获取一个信号量，因为此时是没有信号量的，所以就会阻塞用户线程；内核在知道用户想要发送数据后，就会调用对应的网卡去发送数据，当数据发送完成后就释放一个信号量告知用户线程发送完成，这样子用户线程就得以继续执行。</p>
<p>为了保证 lwip 能够使用以上功能，我们需要将系统实现的相关函数绑定至 <code>sys_arch.c/.h</code>。在 liblwip 中可以看到诸如 <code>mutex.c</code>，<code>semaphore.c</code>，<code>mailbox.c</code>，<code>thread.c</code>，<code>sockets.c</code> 之类的文件，这些就是 unikraft 环境下对接口的实现。</p>
<h2 id="liblwip-初始化"><a href="#liblwip-初始化" class="headerlink" title="liblwip 初始化"></a>liblwip 初始化</h2><p>初始化流程如下图</p>
<p><img src="/images/unikraft-liblwip/lwip_init.svg" alt="初始化流程图"></p>
<p>初始化流程图</p>
<p>整个初始化流程从 <code>liblwip_init</code> 开始，在这个函数中首先调用 <code>tcpip_init</code> 进行协议栈的初始化，随后遍历读取 netdev 列表，对每个 dev 调用 <code>uk_netdev_addif</code> 函数。这个函数完成对 <code>netif</code> 的内存分配后调用 <code>netif_add</code> 函数，将原本的 <code>uk_netdev</code> 结构体存入 <code>*state</code> 字段后调用指定的 init 函数 <code>uknetdev_init</code>。在这个函数中调用 dev → ops 中注册好的各种函数进行配置以及启动设备。我们分函数走完这个初始化流程</p>
<p>最开始调用的函数是是 <code>liblwip_init</code> </p>
<blockquote>
<p><del>暂不清楚以何种方式调用：</del><code>uk_lib_initcall(liblwip_init);</code> <del>猜测可能是宏定义</del><br>确实是宏定义，让注册的函数在 bootstrap 阶段就开始执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Register a Unikraft init function that is called during bootstrap (uk_inittab)</span><br></pre></td></tr></table></figure>

</blockquote>
<p>在函数中首先调用了 <code>lwip_init</code> 以及 <code>tcpip_init</code> 进行初始化，随后遍历所有的 netdev 并逐个检查配置状态，最后通过 <code>uknetdev_addif</code> 在 lwip 侧添加对应的 netif</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">liblwip_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_LWIP_UKNETDEV &amp;&amp; CONFIG_LWIP_AUTOIFACE</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> devid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netdev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">nf</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>  __maybe_unused *strcfg;</span><br><span class="line">	<span class="type">uint16_t</span>  __maybe_unused int16cfg;</span><br><span class="line">	<span class="type">int</span> is_first_nf;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">	<span class="type">ip4_addr_t</span> ip4;</span><br><span class="line">	<span class="type">ip4_addr_t</span> *ip4_arg;</span><br><span class="line">	<span class="type">ip4_addr_t</span> mask4;</span><br><span class="line">	<span class="type">ip4_addr_t</span> *mask4_arg;</span><br><span class="line">	<span class="type">ip4_addr_t</span> gw4;</span><br><span class="line">	<span class="type">ip4_addr_t</span> *gw4_arg;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_LWIP_UKNETDEV &amp;&amp; CONFIG_LWIP_AUTOIFACE */</span></span></span><br><span class="line"></span><br><span class="line">	uk_pr_info(<span class="string">&quot;Initializing lwip\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !CONFIG_LWIP_NOTHREADS</span></span><br><span class="line">	uk_semaphore_init(&amp;_lwip_init_sem, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !CONFIG_LWIP_NOTHREADS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_LWIP_NOTHREADS</span></span><br><span class="line">	lwip_init();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* CONFIG_LWIP_NOTHREADS */</span></span></span><br><span class="line">	tcpip_init(_lwip_init_done, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Wait until stack is booted */</span></span><br><span class="line">	uk_semaphore_down(&amp;_lwip_init_sem);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_LWIP_NOTHREADS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETIF_EXT_STATUS_CALLBACK &amp;&amp; CONFIG_LWIP_NETIF_STATUS_PRINT</span></span><br><span class="line">	<span class="comment">/* Add print callback for netif state changes */</span></span><br><span class="line">	netif_add_ext_callback(&amp;netif_status_print, _netif_status_print);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETIF_EXT_STATUS_CALLBACK &amp;&amp; CONFIG_LWIP_NETIF_STATUS_PRINT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_LWIP_UKNETDEV &amp;&amp; CONFIG_LWIP_AUTOIFACE</span></span><br><span class="line">	is_first_nf = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 遍历 netdev 列表并进行相应操作</span></span><br><span class="line">	<span class="keyword">for</span> (devid = <span class="number">0</span>; devid &lt; uk_netdev_count(); ++devid) &#123;</span><br><span class="line">		dev = uk_netdev_get(devid);</span><br><span class="line">		<span class="keyword">if</span> (!dev)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (uk_netdev_state_get(dev) != UK_NETDEV_UNCONFIGURED</span><br><span class="line">		    &amp;&amp; uk_netdev_state_get(dev) != UK_NETDEV_UNPROBED) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot;Skipping to add network device %u to lwIP: Not in unconfigured state\n&quot;</span>,</span><br><span class="line">				    devid);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (uk_netdev_state_get(dev) == UK_NETDEV_UNPROBED) &#123;</span><br><span class="line">			ret = uk_netdev_probe(dev);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				uk_pr_err(<span class="string">&quot;Failed to probe features of network device %u: %d; skipping device...\n&quot;</span>,</span><br><span class="line">					  devid, ret);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Here, the device has to be in unconfigured state */</span></span><br><span class="line">		UK_ASSERT(uk_netdev_state_get(dev) == UK_NETDEV_UNCONFIGURED);</span><br><span class="line"></span><br><span class="line">		uk_pr_info(<span class="string">&quot;Attach network device %u to lwIP...\n&quot;</span>,</span><br><span class="line">			   devid);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">		ip4_arg   = <span class="literal">NULL</span>;</span><br><span class="line">		mask4_arg = <span class="literal">NULL</span>;</span><br><span class="line">		gw4_arg   = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* IP */</span></span><br><span class="line">		strcfg = uk_netdev_einfo_get(dev, UK_NETDEV_IPV4_ADDR_STR);</span><br><span class="line">		<span class="keyword">if</span> (strcfg) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ip4addr_aton(strcfg, &amp;ip4) != <span class="number">1</span>) &#123;</span><br><span class="line">				uk_pr_err(<span class="string">&quot;Error converting IP address: %s\n&quot;</span>,</span><br><span class="line">						strcfg);</span><br><span class="line">				<span class="keyword">goto</span> no_conf;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">goto</span> no_conf;</span><br><span class="line">		ip4_arg = &amp;ip4;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* mask */</span></span><br><span class="line">		strcfg = uk_netdev_einfo_get(dev, UK_NETDEV_IPV4_MASK_STR);</span><br><span class="line">		<span class="keyword">if</span> (strcfg) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ip4addr_aton(strcfg, &amp;mask4) != <span class="number">1</span>) &#123;</span><br><span class="line">				uk_pr_err(<span class="string">&quot;Error converting net mask: %s\n&quot;</span>,</span><br><span class="line">						strcfg);</span><br><span class="line">				<span class="keyword">goto</span> no_conf;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="comment">/* default mask */</span></span><br><span class="line">			ip4_addr_set_u32(&amp;mask4, lwip_htonl(IP_CLASSC_NET));</span><br><span class="line">		mask4_arg = &amp;mask4;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* gateway */</span></span><br><span class="line">		strcfg = uk_netdev_einfo_get(dev, UK_NETDEV_IPV4_GW_STR);</span><br><span class="line">		<span class="keyword">if</span> (strcfg) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ip4addr_aton(strcfg, &amp;gw4) != <span class="number">1</span>) &#123;</span><br><span class="line">				uk_pr_err(<span class="string">&quot;Error converting gateway: %s\n&quot;</span>,</span><br><span class="line">						strcfg);</span><br><span class="line">				<span class="keyword">goto</span> no_conf;</span><br><span class="line">			&#125;</span><br><span class="line">			gw4_arg = &amp;gw4;</span><br><span class="line">		&#125;</span><br><span class="line">no_conf:</span><br><span class="line">		nf = uknetdev_addif(dev, ip4_arg, mask4_arg, gw4_arg);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">TODO:</span> Add support for IPv6 device configuration from</span></span><br><span class="line"><span class="comment">		 * netdev&#x27;s econf interface</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		nf = uknetdev_addif(dev);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line">		<span class="keyword">if</span> (!nf) &#123;</span><br><span class="line">			uk_pr_err(<span class="string">&quot;Failed to attach network device %u to lwIP\n&quot;</span>,</span><br><span class="line">				  devid);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Print hardware address */</span></span><br><span class="line">		<span class="keyword">if</span> (nf-&gt;hwaddr_len == <span class="number">6</span>) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot;%c%c%u: Hardware address: %02&quot;</span>PRIx8<span class="string">&quot;:%02&quot;</span>PRIx8<span class="string">&quot;:%02&quot;</span>PRIx8<span class="string">&quot;:%02&quot;</span>PRIx8<span class="string">&quot;:%02&quot;</span>PRIx8<span class="string">&quot;:%02&quot;</span>PRIx8<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">				   nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">				   nf-&gt;hwaddr[<span class="number">0</span>], nf-&gt;hwaddr[<span class="number">1</span>], nf-&gt;hwaddr[<span class="number">2</span>],</span><br><span class="line">				   nf-&gt;hwaddr[<span class="number">3</span>], nf-&gt;hwaddr[<span class="number">4</span>], nf-&gt;hwaddr[<span class="number">5</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_CHECKSUM_CTRL_PER_NETIF</span></span><br><span class="line">		uk_pr_info(<span class="string">&quot;%c%c%u: Check checksums:&quot;</span>,</span><br><span class="line">			   nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num);</span><br><span class="line">		IF__NETIF_CHECKSUM_ENABLED(nf, NETIF_CHECKSUM_CHECK_IP) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot; IP&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		IF__NETIF_CHECKSUM_ENABLED(nf, NETIF_CHECKSUM_CHECK_UDP) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot; UDP&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		IF__NETIF_CHECKSUM_ENABLED(nf, NETIF_CHECKSUM_CHECK_TCP) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot; TCP&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		IF__NETIF_CHECKSUM_ENABLED(nf, NETIF_CHECKSUM_CHECK_ICMP) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot; ICMP&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		IF__NETIF_CHECKSUM_ENABLED(nf, NETIF_CHECKSUM_CHECK_ICMP6) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot; ICMP6&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		uk_pr_info(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		uk_pr_info(<span class="string">&quot;%c%c%u: Generate checksums:&quot;</span>,</span><br><span class="line">			   nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num);</span><br><span class="line">		IF__NETIF_CHECKSUM_ENABLED(nf, NETIF_CHECKSUM_GEN_IP) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot; IP&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		IF__NETIF_CHECKSUM_ENABLED(nf, NETIF_CHECKSUM_GEN_UDP) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot; UDP&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		IF__NETIF_CHECKSUM_ENABLED(nf, NETIF_CHECKSUM_GEN_TCP) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot; TCP&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		IF__NETIF_CHECKSUM_ENABLED(nf, NETIF_CHECKSUM_GEN_ICMP) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot; ICMP&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		IF__NETIF_CHECKSUM_ENABLED(nf, NETIF_CHECKSUM_GEN_ICMP6) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot; ICMP6&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		uk_pr_info(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_CHECKSUM_CTRL_PER_NETIF */</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Declare the first network device as default interface */</span></span><br><span class="line">		<span class="keyword">if</span> (is_first_nf) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot;%c%c%u: Set as default interface\n&quot;</span>,</span><br><span class="line">				   nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num);</span><br><span class="line">			netif_set_default(nf);</span><br><span class="line">			is_first_nf = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		netif_set_up(nf);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4 &amp;&amp; LWIP_DHCP</span></span><br><span class="line">		<span class="keyword">if</span> (!ip4_arg) &#123;</span><br><span class="line">			uk_pr_info(<span class="string">&quot;%c%c%u: DHCP configuration (background)...\n&quot;</span>,</span><br><span class="line">				   nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num);</span><br><span class="line">			dhcp_start(nf);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 &amp;&amp; LWIP_DHCP */</span></span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_LWIP_UKNETDEV &amp;&amp; CONFIG_LWIP_AUTOIFACE */</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数实际上是 lwip 提供的 <code>netif_add</code> 函数的一层封装，在其中为 netif 分配了内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> netif *<span class="title function_">uknetdev_addif</span><span class="params">(<span class="keyword">struct</span> uk_netdev *n</span></span><br><span class="line"><span class="params">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line"><span class="params">			     ,</span></span><br><span class="line"><span class="params">			     <span class="type">const</span> <span class="type">ip4_addr_t</span> *ipaddr,</span></span><br><span class="line"><span class="params">			     <span class="type">const</span> <span class="type">ip4_addr_t</span> *netmask,</span></span><br><span class="line"><span class="params">			     <span class="type">const</span> <span class="type">ip4_addr_t</span> *gw</span></span><br><span class="line"><span class="params">#endif <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">void</span> *pethernet_input = NETIF_INPUT;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">nf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">	nf = mem_calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(*nf));</span><br><span class="line">	<span class="keyword">if</span> (!nf)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ret = netif_add(nf,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">			ipaddr, netmask, gw,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line">			n, uknetdev_init, UK_READ_ONCE(pethernet_input));</span><br><span class="line">	UK_ASSERT(nf-&gt;input);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		mem_free(nf);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的功能是初始化刚刚分配好的 netif 并将其插入到 netif_list 的链表头部，令 state 字段指向对应的 uk_netdev，调用用户提供的 init 函数对 netif 进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> netif *</span><br><span class="line"><span class="title function_">netif_add</span><span class="params">(<span class="keyword">struct</span> netif *netif,</span></span><br><span class="line"><span class="params">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">ip4_addr_t</span> *ipaddr, <span class="type">const</span> <span class="type">ip4_addr_t</span> *netmask, <span class="type">const</span> <span class="type">ip4_addr_t</span> *gw,</span></span><br><span class="line"><span class="params">#endif <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line"><span class="params">          <span class="type">void</span> *state, netif_init_fn init, netif_input_fn input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV6</span></span><br><span class="line">  <span class="type">s8_t</span> i;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT_CORE_LOCKED();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SINGLE_NETIF</span></span><br><span class="line">  <span class="keyword">if</span> (netif_default != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;single netif already set&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netif_add: invalid netif&quot;</span>, netif != <span class="literal">NULL</span>, <span class="keyword">return</span> <span class="literal">NULL</span>);</span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netif_add: No init function given&quot;</span>, init != <span class="literal">NULL</span>, <span class="keyword">return</span> <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">  <span class="keyword">if</span> (ipaddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ipaddr = ip_2_ip4(IP4_ADDR_ANY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (netmask == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    netmask = ip_2_ip4(IP4_ADDR_ANY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (gw == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    gw = ip_2_ip4(IP4_ADDR_ANY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* reset new interface configuration state */</span></span><br><span class="line">  ip_addr_set_zero_ip4(&amp;netif-&gt;ip_addr);</span><br><span class="line">  ip_addr_set_zero_ip4(&amp;netif-&gt;netmask);</span><br><span class="line">  ip_addr_set_zero_ip4(&amp;netif-&gt;gw);</span><br><span class="line">  netif-&gt;output = netif_null_output_ip4;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV6</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LWIP_IPV6_NUM_ADDRESSES; i++) &#123;</span><br><span class="line">    ip_addr_set_zero_ip6(&amp;netif-&gt;ip6_addr[i]);</span><br><span class="line">    netif-&gt;ip6_addr_state[i] = IP6_ADDR_INVALID;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV6_ADDRESS_LIFETIMES</span></span><br><span class="line">    netif-&gt;ip6_addr_valid_life[i] = IP6_ADDR_LIFE_STATIC;</span><br><span class="line">    netif-&gt;ip6_addr_pref_life[i] = IP6_ADDR_LIFE_STATIC;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV6_ADDRESS_LIFETIMES */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  netif-&gt;output_ip6 = netif_null_output_ip6;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV6 */</span></span></span><br><span class="line">  NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_ENABLE_ALL);</span><br><span class="line">  netif-&gt;mtu = <span class="number">0</span>;</span><br><span class="line">  netif-&gt;flags = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> netif_get_client_data</span></span><br><span class="line">  <span class="built_in">memset</span>(netif-&gt;client_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(netif-&gt;client_data));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NUM_NETIF_CLIENT_DATA */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV6</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV6_AUTOCONFIG</span></span><br><span class="line">  <span class="comment">/* IPv6 address autoconfiguration not enabled by default */</span></span><br><span class="line">  netif-&gt;ip6_autoconfig_enabled = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV6_AUTOCONFIG */</span></span></span><br><span class="line">  nd6_restart_netif(netif);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV6 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETIF_STATUS_CALLBACK</span></span><br><span class="line">  netif-&gt;status_callback = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETIF_STATUS_CALLBACK */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETIF_LINK_CALLBACK</span></span><br><span class="line">  netif-&gt;link_callback = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETIF_LINK_CALLBACK */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IGMP</span></span><br><span class="line">  netif-&gt;igmp_mac_filter = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IGMP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV6 &amp;&amp; LWIP_IPV6_MLD</span></span><br><span class="line">  netif-&gt;mld_mac_filter = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV6 &amp;&amp; LWIP_IPV6_MLD */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* remember netif specific state information data */</span></span><br><span class="line">  netif-&gt;state = state;</span><br><span class="line">  netif-&gt;num = netif_num;</span><br><span class="line">  netif-&gt;input = input;</span><br><span class="line"></span><br><span class="line">  NETIF_RESET_HINTS(netif);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_LOOPBACK</span></span><br><span class="line">  netif-&gt;loop_first = <span class="literal">NULL</span>;</span><br><span class="line">  netif-&gt;loop_last = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_LOOPBACK_MAX_PBUFS</span></span><br><span class="line">  netif-&gt;loop_cnt_current = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_LOOPBACK_MAX_PBUFS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETIF_LOOPBACK_MULTITHREADING</span></span><br><span class="line">  netif-&gt;reschedule_poll = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETIF_LOOPBACK_MULTITHREADING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ENABLE_LOOPBACK */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">  netif_set_addr(netif, ipaddr, netmask, gw);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* call user specified initialization function for netif */</span></span><br><span class="line">  <span class="keyword">if</span> (init(netif) != ERR_OK) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV6 &amp;&amp; LWIP_ND6_ALLOW_RA_UPDATES</span></span><br><span class="line">  <span class="comment">/* Initialize the MTU for IPv6 to the one set by the netif driver.</span></span><br><span class="line"><span class="comment">     This can be updated later by RA. */</span></span><br><span class="line">  netif-&gt;mtu6 = netif-&gt;mtu;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV6 &amp;&amp; LWIP_ND6_ALLOW_RA_UPDATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !LWIP_SINGLE_NETIF</span></span><br><span class="line">  <span class="comment">/* Assign a unique netif number in the range [0..254], so that (num+1) can</span></span><br><span class="line"><span class="comment">     serve as an interface index that fits in a u8_t.</span></span><br><span class="line"><span class="comment">     We assume that the new netif has not yet been added to the list here.</span></span><br><span class="line"><span class="comment">     This algorithm is O(n^2), but that should be OK for lwIP.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">netif2</span>;</span></span><br><span class="line">    <span class="type">int</span> num_netifs;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (netif-&gt;num == <span class="number">255</span>) &#123;</span><br><span class="line">        netif-&gt;num = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      num_netifs = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (netif2 = netif_list; netif2 != <span class="literal">NULL</span>; netif2 = netif2-&gt;next) &#123;</span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;netif already added&quot;</span>, netif2 != netif);</span><br><span class="line">        num_netifs++;</span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;too many netifs, max. supported number is 255&quot;</span>, num_netifs &lt;= <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">if</span> (netif2-&gt;num == netif-&gt;num) &#123;</span><br><span class="line">          netif-&gt;num++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (netif2 != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (netif-&gt;num == <span class="number">254</span>) &#123;</span><br><span class="line">    netif_num = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    netif_num = (<span class="type">u8_t</span>)(netif-&gt;num + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* add this netif to the list */</span></span><br><span class="line">	<span class="comment">// 链表插入部分</span></span><br><span class="line">  netif-&gt;next = netif_list;</span><br><span class="line">  netif_list = netif;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* &quot;LWIP_SINGLE_NETIF */</span></span></span><br><span class="line">  mib2_netif_added(netif);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IGMP</span></span><br><span class="line">  <span class="comment">/* start IGMP processing */</span></span><br><span class="line">  <span class="keyword">if</span> (netif-&gt;flags &amp; NETIF_FLAG_IGMP) &#123;</span><br><span class="line">    igmp_start(netif);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IGMP */</span></span></span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(NETIF_DEBUG, (<span class="string">&quot;netif: added interface %c%c IP&quot;</span>,</span><br><span class="line">                            netif-&gt;name[<span class="number">0</span>], netif-&gt;name[<span class="number">1</span>]));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">  LWIP_DEBUGF(NETIF_DEBUG, (<span class="string">&quot; addr &quot;</span>));</span><br><span class="line">  ip4_addr_debug_print(NETIF_DEBUG, ipaddr);</span><br><span class="line">  LWIP_DEBUGF(NETIF_DEBUG, (<span class="string">&quot; netmask &quot;</span>));</span><br><span class="line">  ip4_addr_debug_print(NETIF_DEBUG, netmask);</span><br><span class="line">  LWIP_DEBUGF(NETIF_DEBUG, (<span class="string">&quot; gw &quot;</span>));</span><br><span class="line">  ip4_addr_debug_print(NETIF_DEBUG, gw);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line">  LWIP_DEBUGF(NETIF_DEBUG, (<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> netif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数中将 <code>uknetdev_input/output</code> 函数注册到 <code>netif</code> 中，并且完成了 <code>netif</code> 和 <code>uk_netdev</code> 两种结构体的映射工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span> <span class="title function_">uknetdev_init</span><span class="params">(<span class="keyword">struct</span> netif *nf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_alloc</span> *<span class="title">a</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netdev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netdev_conf</span> <span class="title">dev_conf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netdev_rxqueue_conf</span> <span class="title">rxq_conf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netdev_txqueue_conf</span> <span class="title">txq_conf</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lwip_netdev_data</span> *<span class="title">lwip_data</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uk_hwaddr</span> *<span class="title">hwaddr</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">// netif 中的 state 字段存储的是相对应的 uk_netdev</span></span><br><span class="line">	UK_ASSERT(nf);</span><br><span class="line">	dev = netif_to_uknetdev(nf);</span><br><span class="line">	UK_ASSERT(dev);</span><br><span class="line"></span><br><span class="line">	lwip_data = (<span class="keyword">struct</span> lwip_netdev_data *)dev-&gt;scratch_pad;</span><br><span class="line"></span><br><span class="line">	LWIP_ASSERT(<span class="string">&quot;uknetdev needs an input callback (netif_input or tcpip_input)&quot;</span>,</span><br><span class="line">		    nf-&gt;input != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Netdev has to be in unconfigured state */</span></span><br><span class="line">	<span class="keyword">if</span> (uk_netdev_state_get(dev) != UK_NETDEV_UNCONFIGURED) &#123;</span><br><span class="line">		LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">			    (<span class="string">&quot;%s: Netdev %u not in uncofigured state\n&quot;</span>,</span><br><span class="line">			     __func__, uk_netdev_id_get(dev)));</span><br><span class="line">		<span class="keyword">return</span> ERR_ISCONN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Interface name, the interface number (nf-&gt;num) is assigned by lwip */</span></span><br><span class="line">	nf-&gt;name[<span class="number">0</span>] = UKNETDEV_NETIF_NAME0;</span><br><span class="line">	nf-&gt;name[<span class="number">1</span>] = UKNETDEV_NETIF_NAME1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bring up uknetdev</span></span><br><span class="line"><span class="comment">	 * Note: We use the default allocator for setting up the rx/tx queues</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> In case the device initialization should happen manually before</span></span><br><span class="line"><span class="comment">	 *       attaching to lwip, we require another init function that skips</span></span><br><span class="line"><span class="comment">	 *       this initialization steps.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	a = uk_alloc_get_default();</span><br><span class="line">	<span class="keyword">if</span> (!a)</span><br><span class="line">		<span class="keyword">return</span> ERR_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get device information */</span></span><br><span class="line">	uk_netdev_info_get(dev, &amp;lwip_data-&gt;dev_info);</span><br><span class="line">	<span class="keyword">if</span> (!lwip_data-&gt;dev_info.max_rx_queues</span><br><span class="line">	    || !lwip_data-&gt;dev_info.max_tx_queues)</span><br><span class="line">		<span class="keyword">return</span> ERR_IF;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_LWIP_UKNETDEV_POLLONLY</span></span><br><span class="line">	<span class="comment">/* Unset receive interrupt support: We force polling mode */</span></span><br><span class="line">	lwip_data-&gt;dev_info.features &amp;= ~UK_FEATURE_RXQ_INTR_AVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_LWIP_UKNETDEV_POLLONLY */</span></span></span><br><span class="line">	lwip_data-&gt;pkt_a = a;</span><br><span class="line"></span><br><span class="line">	LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">		    (<span class="string">&quot;%s: %c%c%u: Headroom rx:%&quot;</span>PRIu16<span class="string">&quot;, tx:%&quot;</span>PRIu16<span class="string">&quot;; I/O align: 0x%&quot;</span>PRIx16<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">		     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">		     lwip_data-&gt;dev_info.nb_encap_rx,</span><br><span class="line">		     lwip_data-&gt;dev_info.nb_encap_tx,</span><br><span class="line">		     lwip_data-&gt;dev_info.ioalign));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Device configuration,</span></span><br><span class="line"><span class="comment">	 * we want to use just one queue for each direction</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dev_conf.nb_rx_queues = <span class="number">1</span>;</span><br><span class="line">	dev_conf.nb_tx_queues = <span class="number">1</span>;</span><br><span class="line">	ret = uk_netdev_configure(dev, &amp;dev_conf);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">			    (<span class="string">&quot;%s: %c%c%u: Failed to configure netdev %u\n&quot;</span>,</span><br><span class="line">			     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">			     uk_netdev_id_get(dev)));</span><br><span class="line">		<span class="keyword">return</span> ERR_IF;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Receive queue,</span></span><br><span class="line"><span class="comment">	 * use driver default descriptors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rxq_conf.a = a;</span><br><span class="line">	rxq_conf.alloc_rxpkts = netif_alloc_rxpkts;</span><br><span class="line">	rxq_conf.alloc_rxpkts_argp = lwip_data;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LWIP_NOTHREADS</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In mainloop mode, we will not use interrupts.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rxq_conf.callback = <span class="literal">NULL</span>;</span><br><span class="line">	rxq_conf.callback_cookie = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  <span class="comment">/* CONFIG_LWIP_NOTHREADS */</span></span></span><br><span class="line">	rxq_conf.callback = uknetdev_input;</span><br><span class="line">	rxq_conf.callback_cookie = nf;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LIBUKNETDEV_DISPATCHERTHREADS</span></span><br><span class="line">	rxq_conf.s = uk_sched_get_default();</span><br><span class="line">	<span class="keyword">if</span> (!rxq_conf.s)</span><br><span class="line">		<span class="keyword">return</span> ERR_IF;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_LIBUKNETDEV_DISPATCHERTHREADS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_LWIP_NOTHREADS */</span></span></span><br><span class="line">	ret = uk_netdev_rxq_configure(dev, <span class="number">0</span>, <span class="number">0</span>, &amp;rxq_conf);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">			    (<span class="string">&quot;%s: %c%c%u: Failed to configure rx queue of netdev %u\n&quot;</span>,</span><br><span class="line">			     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">			     uk_netdev_id_get(dev)));</span><br><span class="line">		<span class="keyword">return</span> ERR_IF;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Transmit queue,</span></span><br><span class="line"><span class="comment">	 * use driver default descriptors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	txq_conf.a = a;</span><br><span class="line">	ret = uk_netdev_txq_configure(dev, <span class="number">0</span>, <span class="number">0</span>, &amp;txq_conf);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">			    (<span class="string">&quot;%s: %c%c%u: Failed to configure tx queue of netdev %u\n&quot;</span>,</span><br><span class="line">			     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">			     uk_netdev_id_get(dev)));</span><br><span class="line">		<span class="keyword">return</span> ERR_IF;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Start interface */</span></span><br><span class="line">	ret = uk_netdev_start(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">			    (<span class="string">&quot;%s: %c%c%u: Failed to start netdev %u\n&quot;</span>,</span><br><span class="line">			     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">			     uk_netdev_id_get(dev)));</span><br><span class="line">		<span class="keyword">return</span> ERR_IF;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Driver callbacks */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">	nf-&gt;output = etharp_output;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV6</span></span><br><span class="line">	nf-&gt;output_ip6 = ethip6_output;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV6 */</span></span></span><br><span class="line">	nf-&gt;linkoutput = uknetdev_output;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> Set remove callback */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device capabilities */</span></span><br><span class="line">	netif_set_flags(nf, (NETIF_FLAG_BROADCAST</span><br><span class="line">			     | NETIF_FLAG_ETHARP</span><br><span class="line">			     | NETIF_FLAG_LINK_UP));</span><br><span class="line">	LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">		    (<span class="string">&quot;%s: %c%c%u: flags: %&quot;</span>PRIx8<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">		     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num, nf-&gt;flags));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_CHECKSUM_CTRL_PER_NETIF</span></span><br><span class="line">	NETIF_SET_CHECKSUM_CTRL(nf, (NETIF_CHECKSUM_GEN_IP</span><br><span class="line">				     | NETIF_CHECKSUM_GEN_UDP</span><br><span class="line">				     | NETIF_CHECKSUM_GEN_TCP</span><br><span class="line">				     | NETIF_CHECKSUM_GEN_ICMP</span><br><span class="line">				     | NETIF_CHECKSUM_GEN_ICMP6));</span><br><span class="line">	LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">		    (<span class="string">&quot;%s: %c%c%u: chksum_flags: %&quot;</span>PRIx16<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">		     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">		     nf-&gt;chksum_flags));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_CHECKSUM_CTRL_PER_NETIF */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* MAC address */</span></span><br><span class="line">	UK_ASSERT(NETIF_MAX_HWADDR_LEN &gt;= UK_NETDEV_HWADDR_LEN);</span><br><span class="line">	hwaddr = uk_netdev_hwaddr_get(dev);</span><br><span class="line">	UK_ASSERT(hwaddr);</span><br><span class="line">	nf-&gt;hwaddr_len = UK_NETDEV_HWADDR_LEN;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; UK_NETDEV_HWADDR_LEN; ++i)</span><br><span class="line">		nf-&gt;hwaddr[i] = hwaddr-&gt;addr_bytes[i];</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UK_NETDEV_HWADDR_LEN == 6</span></span><br><span class="line">	LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">		    (<span class="string">&quot;%s: %c%c%u: Hardware address: %02&quot;</span>PRIx8<span class="string">&quot;:%02&quot;</span>PRIx8<span class="string">&quot;:%02&quot;</span>PRIx8<span class="string">&quot;:%02&quot;</span>PRIx8<span class="string">&quot;:%02&quot;</span>PRIx8<span class="string">&quot;:%02&quot;</span>PRIx8<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">		     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">		     nf-&gt;hwaddr[<span class="number">0</span>], nf-&gt;hwaddr[<span class="number">1</span>], nf-&gt;hwaddr[<span class="number">2</span>],</span><br><span class="line">		     nf-&gt;hwaddr[<span class="number">3</span>], nf-&gt;hwaddr[<span class="number">4</span>], nf-&gt;hwaddr[<span class="number">5</span>]));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* UK_NETDEV_HWADDR_LEN */</span></span></span><br><span class="line">	LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">		    (<span class="string">&quot;%s: %c%c%u: Hardware address set\n&quot;</span>,</span><br><span class="line">		     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* UK_NETDEV_HWADDR_LEN */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Maximum transfer unit */</span></span><br><span class="line">	nf-&gt;mtu = uk_netdev_mtu_get(dev);</span><br><span class="line">	UK_ASSERT(nf-&gt;mtu);</span><br><span class="line">	LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">		    (<span class="string">&quot;%s: %c%c%u: MTU: %u\n&quot;</span>,</span><br><span class="line">		     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">		     nf-&gt;mtu));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_LWIP_NOTHREADS</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We will use the status update callback to enable and disabled</span></span><br><span class="line"><span class="comment">	 * receive queue interrupts</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	netif_set_status_callback(nf, uknetdev_updown);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !CONFIG_LWIP_NOTHREADS */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the snmp variables and counters inside the struct netif.</span></span><br><span class="line"><span class="comment">	 * The last argument is the link speed, in units of bits per second.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NETIF_INIT_SNMP(nf, snmp_ifType_ethernet_csmacd, UKNETDEV_BPS);</span><br><span class="line">	LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">		    (<span class="string">&quot;%s: %c%c%u: Link speed: %&quot;</span>PRIu32<span class="string">&quot; bps\n&quot;</span>,</span><br><span class="line">		     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">		     UKNETDEV_BPS));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lwip-与-unikraft-结构映射"><a href="#lwip-与-unikraft-结构映射" class="headerlink" title="lwip 与 unikraft 结构映射"></a>lwip 与 unikraft 结构映射</h2><p><img src="/images/unikraft-liblwip/unikraft-lwip.svg" alt="结构映射"></p>
<p>上图所示的对应结构是连接 unikraft 和 lwip 的关键部分。下面对 lwip 下的两个结构进行介绍。</p>
<p>此处介绍结构体 <code>netif</code>。netif 是用于描述网络接口/网卡的一种结构体，同样存储在一张链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lwip 的网络接口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netif</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !LWIP_SINGLE_NETIF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">	<span class="comment">// IPv4 下使用的地址掩码及网关</span></span><br><span class="line">  <span class="type">ip_addr_t</span> ip_addr;</span><br><span class="line">  <span class="type">ip_addr_t</span> netmask;</span><br><span class="line">  <span class="type">ip_addr_t</span> gw;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line">	<span class="comment">// 传送上行数据 网卡-&gt;协议栈</span></span><br><span class="line">  netif_input_fn input;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">	<span class="comment">// 传送下行数据 协议栈-&gt;网卡</span></span><br><span class="line">  netif_output_fn output;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line">  netif_linkoutput_fn linkoutput;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETIF_STATUS_CALLBACK</span></span><br><span class="line">	<span class="comment">// 当网卡状态发生变化时调用</span></span><br><span class="line">  netif_status_callback_fn status_callback;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETIF_STATUS_CALLBACK */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETIF_LINK_CALLBACK</span></span><br><span class="line">	<span class="comment">// 连接发生变化时调用</span></span><br><span class="line">  netif_status_callback_fn link_callback;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETIF_LINK_CALLBACK */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETIF_REMOVE_CALLBACK</span></span><br><span class="line">  <span class="comment">/** This function is called when the netif has been removed */</span></span><br><span class="line">	<span class="comment">// 网卡移除时调用</span></span><br><span class="line">  netif_status_callback_fn remove_callback;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETIF_REMOVE_CALLBACK */</span></span></span><br><span class="line">	<span class="comment">// 在网卡驱动中配置该参数，用于存储网卡的状态，在 unikraft 中存储的就是 uknetdev</span></span><br><span class="line">  <span class="type">void</span> *state;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> netif_get_client_data</span></span><br><span class="line">  <span class="type">void</span>* client_data[LWIP_NETIF_CLIENT_DATA_INDEX_MAX + LWIP_NUM_NETIF_CLIENT_DATA];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETIF_HOSTNAME</span></span><br><span class="line">	<span class="comment">// 该网卡的主机名</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>*  hostname;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETIF_HOSTNAME */</span></span></span><br><span class="line">	<span class="comment">// **对比原 lwip 缺失了 dhcp 以及 autoip**</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_CHECKSUM_CTRL_PER_NETIF</span></span><br><span class="line">  <span class="type">u16_t</span> chksum_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_CHECKSUM_CTRL_PER_NETIF*/</span></span></span><br><span class="line">  <span class="comment">/** maximum transfer unit (in bytes) */</span></span><br><span class="line">	<span class="comment">// 最大传输单元</span></span><br><span class="line">  <span class="type">u16_t</span> mtu;</span><br><span class="line">  <span class="comment">/** link level hardware address of this interface */</span></span><br><span class="line">	<span class="comment">// MAC 地址</span></span><br><span class="line">  <span class="type">u8_t</span> hwaddr[NETIF_MAX_HWADDR_LEN];</span><br><span class="line">  <span class="comment">/** number of bytes used in hwaddr */</span></span><br><span class="line">  <span class="type">u8_t</span> hwaddr_len;</span><br><span class="line">  <span class="comment">/** flags (@see @ref netif_flags) */</span></span><br><span class="line">	<span class="comment">// 标志位</span></span><br><span class="line">  <span class="type">u8_t</span> flags;</span><br><span class="line">  <span class="comment">/** descriptive abbreviation */</span></span><br><span class="line">	<span class="comment">// 网卡名称缩写</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">2</span></span><br><span class="line">	<span class="comment">// 编号</span></span><br><span class="line">  <span class="type">u8_t</span> num;</span><br><span class="line">	<span class="comment">// 此处缺失 SNMP 相关</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MIB2_STATS</span></span><br><span class="line">  <span class="comment">/** link type (from &quot;snmp_ifType&quot; enum from snmp_mib2.h) */</span></span><br><span class="line">  <span class="type">u8_t</span> link_type;</span><br><span class="line">  <span class="comment">/** (estimate) link speed */</span></span><br><span class="line">  <span class="type">u32_t</span> link_speed;</span><br><span class="line">  <span class="comment">/** timestamp at last change made (up/down) */</span></span><br><span class="line">  <span class="type">u32_t</span> ts;</span><br><span class="line">  <span class="comment">/** counters */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stats_mib2_netif_ctrs</span> <span class="title">mib2_counters</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* MIB2_STATS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4 &amp;&amp; LWIP_IGMP</span></span><br><span class="line">  <span class="comment">/** This function could be called to add or delete an entry in the multicast</span></span><br><span class="line"><span class="comment">      filter table of the ethernet MAC.*/</span></span><br><span class="line">  netif_igmp_mac_filter_fn igmp_mac_filter;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 &amp;&amp; LWIP_IGMP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETIF_USE_HINTS</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif_hint</span> *<span class="title">hints</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETIF_USE_HINTS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_LOOPBACK</span></span><br><span class="line">  <span class="comment">/* List of packets to be queued for ourselves. */</span></span><br><span class="line">	<span class="comment">// 支持本地回传所需的参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">loop_first</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">loop_last</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_LOOPBACK_MAX_PBUFS</span></span><br><span class="line">  <span class="type">u16_t</span> loop_cnt_current;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_LOOPBACK_MAX_PBUFS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETIF_LOOPBACK_MULTITHREADING</span></span><br><span class="line">  <span class="comment">/* Used if the original scheduling failed. */</span></span><br><span class="line">  <span class="type">u8_t</span> reschedule_poll;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETIF_LOOPBACK_MULTITHREADING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ENABLE_LOOPBACK */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是 <code>netif</code> 中的 flags，用来标志 netif 的类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NETIF_FLAG_UP           0x01U</span></span><br><span class="line"><span class="comment">/** If set, the netif has broadcast capability.</span></span><br><span class="line"><span class="comment"> * Set by the netif driver in its init function. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETIF_FLAG_BROADCAST    0x02U</span></span><br><span class="line"><span class="comment">/** If set, the interface has an active link</span></span><br><span class="line"><span class="comment"> *  (set by the network interface driver).</span></span><br><span class="line"><span class="comment"> * Either set by the netif driver in its init function (if the link</span></span><br><span class="line"><span class="comment"> * is up at that time) or at a later point once the link comes up</span></span><br><span class="line"><span class="comment"> * (if link detection is supported by the hardware). */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETIF_FLAG_LINK_UP      0x04U</span></span><br><span class="line"><span class="comment">/** If set, the netif is an ethernet device using ARP.</span></span><br><span class="line"><span class="comment"> * Set by the netif driver in its init function.</span></span><br><span class="line"><span class="comment"> * Used to check input packet types and use of DHCP. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETIF_FLAG_ETHARP       0x08U</span></span><br><span class="line"><span class="comment">/** If set, the netif is an ethernet device. It might not use</span></span><br><span class="line"><span class="comment"> * ARP or TCP/IP if it is used for PPPoE only.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETIF_FLAG_ETHERNET     0x10U</span></span><br><span class="line"><span class="comment">/** If set, the netif has IGMP capability.</span></span><br><span class="line"><span class="comment"> * Set by the netif driver in its init function. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETIF_FLAG_IGMP         0x20U</span></span><br><span class="line"><span class="comment">/** If set, the netif has MLD6 capability.</span></span><br><span class="line"><span class="comment"> * Set by the netif driver in its init function. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETIF_FLAG_MLD6         0x40U</span></span><br></pre></td></tr></table></figure>

<p>在 <code>netbuf.h</code> 文件中我们可以看到 <code>lwip</code> 库使用的 <code>pbuf</code>，其目的是在原本的 <code>netbuf</code> 基础上嵌入特定协议栈的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">netbuf_pbuf</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pbuf_custom</span> <span class="title">pbuf_custom</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netbuf</span> *<span class="title">netbuf</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>pbuf.h/pbuf_custom</code> 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pbuf_custom</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> <span class="title">pbuf</span>;</span></span><br><span class="line">  pbuf_free_custom_fn custom_free_function;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>pbuf</code> 结构体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> &#123;</span></span><br><span class="line">	<span class="comment">// pbuf 链为单链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="comment">// 指向实际负载数据</span></span><br><span class="line">  <span class="type">void</span> *payload;</span><br><span class="line">	<span class="comment">// 截至该 pbuf 的总长度</span></span><br><span class="line">  <span class="type">u16_t</span> tot_len;</span><br><span class="line">  <span class="type">u16_t</span> len;</span><br><span class="line">	<span class="comment">// pbuf 内部类型</span></span><br><span class="line">  <span class="type">u8_t</span> type_internal;</span><br><span class="line">	<span class="comment">// 各种各样的标志</span></span><br><span class="line">  <span class="type">u8_t</span> flags;</span><br><span class="line">	<span class="comment">// 引用计数，来自应用、栈本身或 pbuf 链中的 pbuf-&gt;next</span></span><br><span class="line">  LWIP_PBUF_REF_T ref;</span><br><span class="line">	<span class="comment">// netif 的索引</span></span><br><span class="line">  <span class="type">u8_t</span> if_idx;</span><br><span class="line">  LWIP_PBUF_CUSTOM_DATA</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>type_internal</code> 有如下几个选项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 pbuf 结构体与 payload 部分的内存直接连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS       0x80</span></span><br><span class="line"><span class="comment">// 声明在这个 pbuf 中的数据是可以修改的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_TYPE_FLAG_DATA_VOLATILE                0x40</span></span><br><span class="line"><span class="comment">// 内存分配来源掩码 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_TYPE_ALLOC_SRC_MASK                    0x0F</span></span><br><span class="line"><span class="comment">// 声明该 pbuf 用于 RX （底下这俩位置怪怪的）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_ALLOC_FLAG_RX                          0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_ALLOC_FLAG_DATA_CONTIGUOUS             0x0200</span></span><br><span class="line"><span class="comment">// 具体的内存分配来源</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP           0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF      0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL 0x02</span></span><br><span class="line"><span class="comment">// 应用可自行设置的分配位置代码 从 3 ~ 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_TYPE_ALLOC_SRC_MASK_APP_MIN            0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_TYPE_ALLOC_SRC_MASK_APP_MAX            PBUF_TYPE_ALLOC_SRC_MASK</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>copy 与 duplicate 的区别？</p>
</blockquote>
<p>还定义了一个枚举结构，通过对以上标志位的组合来代表不同类型的 pbuf</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  <span class="comment">/** pbuf data is stored in RAM, used for TX mostly, struct pbuf and its payload</span></span><br><span class="line"><span class="comment">      are allocated in one piece of contiguous memory (so the first payload byte</span></span><br><span class="line"><span class="comment">      can be calculated from struct pbuf).</span></span><br><span class="line"><span class="comment">      pbuf_alloc() allocates PBUF_RAM pbufs as unchained pbufs (although that might</span></span><br><span class="line"><span class="comment">      change in future versions).</span></span><br><span class="line"><span class="comment">      This should be used for all OUTGOING packets (TX).*/</span></span><br><span class="line">  PBUF_RAM = (PBUF_ALLOC_FLAG_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP),</span><br><span class="line">  <span class="comment">/** pbuf data is stored in ROM, i.e. struct pbuf and its payload are located in</span></span><br><span class="line"><span class="comment">      totally different memory areas. Since it points to ROM, payload does not</span></span><br><span class="line"><span class="comment">      have to be copied when queued for transmission. */</span></span><br><span class="line">  PBUF_ROM = PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF,</span><br><span class="line">  <span class="comment">/** pbuf comes from the pbuf pool. Much like PBUF_ROM but payload might change</span></span><br><span class="line"><span class="comment">      so it has to be duplicated when queued before transmitting, depending on</span></span><br><span class="line"><span class="comment">      who has a &#x27;ref&#x27; to it. */</span></span><br><span class="line">  PBUF_REF = (PBUF_TYPE_FLAG_DATA_VOLATILE | PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF),</span><br><span class="line">  <span class="comment">/** pbuf payload refers to RAM. This one comes from a pool and should be used</span></span><br><span class="line"><span class="comment">      for RX. Payload can be chained (scatter-gather RX) but like PBUF_RAM, struct</span></span><br><span class="line"><span class="comment">      pbuf and its payload are allocated in one piece of contiguous memory (so</span></span><br><span class="line"><span class="comment">      the first payload byte can be calculated from struct pbuf).</span></span><br><span class="line"><span class="comment">      Don&#x27;t use this for TX, if the pool becomes empty e.g. because of TCP queuing,</span></span><br><span class="line"><span class="comment">      you are unable to receive TCP acks! */</span></span><br><span class="line">  PBUF_POOL = (PBUF_ALLOC_FLAG_RX | PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL)</span><br><span class="line">&#125; pbuf_type;</span><br></pre></td></tr></table></figure>

<p>pbuf 中的 flags 各位定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明该数据包应该立即传递给应用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_PUSH      0x01U</span></span><br><span class="line"><span class="comment">// 声明这是一个定制的 pbuf，在释放空间时应该调用 pbuf_custom-&gt;custom_free_function()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_IS_CUSTOM 0x02U</span></span><br><span class="line"><span class="comment">// 声明该 pbuf 是 UDP 的多播</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_MCASTLOOP 0x04U</span></span><br><span class="line"><span class="comment">// 声明该 pbuf 是链接级的广播包</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_LLBCAST   0x08U</span></span><br><span class="line"><span class="comment">// 声明该 pbuf 是链接级的多播包</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_LLMCAST   0x10U</span></span><br><span class="line"><span class="comment">//声明该 pbuf 包含 TCP 协议中的 FIN 标志位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBUF_FLAG_TCP_FIN   0x20U</span></span><br></pre></td></tr></table></figure>

<p>最后 pbuf 与 netbuf 形成了以下结构，这种结构方便再在两者之间快速切换</p>
<p><img src="/images/unikraft-liblwip/_netbuf_pbuf.png" alt="_netbuf_pbuf"></p>
<p>结构示意图</p>
<p>其中的 <code>_netbuf_pbuf</code> 就是 <code>netbuf.h</code> 中提到的 <code>private meta data</code></p>
<p>该结构的构建部分位于 <code>lwip_alloc_netbuf</code> 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> uk_netbuf *<span class="title function_">lwip_alloc_netbuf</span><span class="params">(<span class="keyword">struct</span> uk_alloc *a, <span class="type">size_t</span> alloc_size,</span></span><br><span class="line"><span class="params">				    <span class="type">size_t</span> alloc_align, <span class="type">uint16_t</span> headroom)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netbuf</span> *<span class="title">b</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">netbuf_pbuf</span> *<span class="title">np</span>;</span></span><br><span class="line"></span><br><span class="line">	b = uk_netbuf_alloc_buf(a, alloc_size, alloc_align,</span><br><span class="line">				headroom, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> _netbuf_pbuf), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!b)) &#123;</span><br><span class="line">		LWIP_DEBUGF(PBUF_DEBUG,</span><br><span class="line">			    (<span class="string">&quot;Failed to allocate netbuf with encapsulated pbuf: requested headroom: %&quot;</span>__PRIu16<span class="string">&quot;, size: %&quot;</span>__PRIsz<span class="string">&quot;, alignement: %&quot;</span>__PRIsz<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">			     headroom, alloc_size, alloc_align));</span><br><span class="line">		<span class="keyword">goto</span> err_out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fill-out meta data */</span></span><br><span class="line">	np = (<span class="keyword">struct</span> _netbuf_pbuf *) uk_netbuf_get_priv(b);</span><br><span class="line">	<span class="built_in">memset</span>(np, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> _netbuf_pbuf));</span><br><span class="line">	np-&gt;pbuf_custom.pbuf.type_internal   = PBUF_ROM;</span><br><span class="line">	np-&gt;pbuf_custom.pbuf.flags           = PBUF_FLAG_IS_CUSTOM;</span><br><span class="line">	np-&gt;pbuf_custom.pbuf.payload         = b-&gt;data;</span><br><span class="line">	np-&gt;pbuf_custom.pbuf.ref             = <span class="number">1</span>;</span><br><span class="line">	np-&gt;pbuf_custom.custom_free_function = _netbuf_free;</span><br><span class="line">	np-&gt;netbuf = b;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set length of netbuf to available space so that it</span></span><br><span class="line"><span class="comment">	 * can be used as receive buffer</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	b-&gt;len = b-&gt;buflen - headroom;</span><br><span class="line"></span><br><span class="line">	LWIP_DEBUGF(PBUF_DEBUG,</span><br><span class="line">		    (<span class="string">&quot;Allocated netbuf with encapsulated pbuf %p (buflen: %&quot;</span>__PRIsz<span class="string">&quot;, headroom: %&quot;</span>__PRIsz<span class="string">&quot;)\n&quot;</span>,</span><br><span class="line">		     b, b-&gt;buflen, uk_netbuf_headroom(b)));</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">err_out:</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="input-执行流程"><a href="#input-执行流程" class="headerlink" title="input 执行流程"></a>input 执行流程</h2><p><img src="/images/unikraft-liblwip/input_stream.svg" alt="input 执行流程"></p>
<p>在 unikraft 中一共有两种调取 input 相关函数的方式：中断和轮询。</p>
<p>从图中可以看出，<code>uknetdev_input</code> 位于核心的地方，这个函数便是连接起 lwip 与 unikraft 的桥梁。它响应来自 unikraft 的调用后通过调用 <code>uk_netdev_rx_one</code> 从 <code>uk_netdev</code> 获取 netbuf，将其转化为 lwip 所使用的 pbuf 后调用对应的 netif 提供的 input 函数将数据包传递给上层协议。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uknetdev_input</span><span class="params">(<span class="keyword">struct</span> uk_netdev *dev,</span></span><br><span class="line"><span class="params">			   <span class="type">uint16_t</span> queue_id __unused, <span class="type">void</span> *argp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">nf</span> =</span> (<span class="keyword">struct</span> netif *) argp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netbuf</span> *<span class="title">nb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="type">err_t</span> err;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	UK_ASSERT(dev);</span><br><span class="line">	UK_ASSERT(nf);</span><br><span class="line">	UK_ASSERT(nf-&gt;input);</span><br><span class="line"></span><br><span class="line">	LWIP_DEBUGF(NETIF_DEBUG, (<span class="string">&quot;%s: %c%c%u: Poll receive queue...\n&quot;</span>,</span><br><span class="line">				  __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num));</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// 调用函数接收数据包并判断设备的状态</span></span><br><span class="line">		ret = uk_netdev_rx_one(dev, <span class="number">0</span>, &amp;nb);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(ret &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">			uk_pr_crit(<span class="string">&quot;%c%c%u: Receive error %d. Stopping interface...\n&quot;</span>,</span><br><span class="line">				   nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num, ret);</span><br><span class="line">			<span class="comment">// 收包出现错误时关闭接口并跳出循环</span></span><br><span class="line">			netif_set_down(nf);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果没有数据包则停止</span></span><br><span class="line">		<span class="keyword">if</span> (uk_netdev_status_notready(ret)) &#123;</span><br><span class="line">			<span class="comment">/* No (more) packets received */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将接收到的 netbuf 转化为 pbuf 供 lwip 使用</span></span><br><span class="line">		p = lwip_netbuf_to_pbuf(nb);</span><br><span class="line">		p-&gt;payload = nb-&gt;data;</span><br><span class="line">		p-&gt;tot_len = p-&gt;len = nb-&gt;len;</span><br><span class="line">		err = nf-&gt;input(p, nf);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(err != ERR_OK)) &#123;</span><br><span class="line">		<span class="comment">// 错误处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_LWIP_THREADS &amp;&amp; CONFIG_LIBUKNETDEV_DISPATCHERTHREADS</span></span><br><span class="line">			<span class="comment">/* At this point it is possible that lwIP&#x27;s input queue</span></span><br><span class="line"><span class="comment">			 * is full or we run out of memory. In this case, we</span></span><br><span class="line"><span class="comment">			 * return to the scheduler and hope that lwIP&#x27;s main</span></span><br><span class="line"><span class="comment">			 * thread is able to process some packets.</span></span><br><span class="line"><span class="comment">			 * Afterwards, we try it once again.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (err == ERR_MEM) &#123;</span><br><span class="line">				LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">					    (<span class="string">&quot;%s: %c%c%u: lwIP&#x27;s input queue full: yielding and trying once again...\n&quot;</span>,</span><br><span class="line">					     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>],</span><br><span class="line">					     nf-&gt;num));</span><br><span class="line">				<span class="comment">// 内存满，令当前线程挂起</span></span><br><span class="line">				uk_sched_yield();</span><br><span class="line">				err = nf-&gt;input(p, nf);</span><br><span class="line">				<span class="keyword">if</span> (likely(err == ERR_OK))</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Drop the packet that we could not send to the stack</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			uk_pr_err(<span class="string">&quot;%c%c%u: Failed to forward packet to lwIP: %d\n&quot;</span>,</span><br><span class="line">				  nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num, err);</span><br><span class="line">			uk_netbuf_free_single(nb);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (uk_netdev_status_more(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数通过判断 netif 的状态来修改中断的状态，并且调用 poll 功能的相关函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uknetdev_updown</span><span class="params">(<span class="keyword">struct</span> netif *nf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netdev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lwip_netdev_data</span>  *<span class="title">lwip_data</span>;</span></span><br><span class="line"></span><br><span class="line">	UK_ASSERT(nf);</span><br><span class="line">	dev = netif_to_uknetdev(nf);</span><br><span class="line">	UK_ASSERT(dev);</span><br><span class="line">	lwip_data = (<span class="keyword">struct</span> lwip_netdev_data *)dev-&gt;scratch_pad;</span><br><span class="line">	<span class="comment">// 通过判断 netif 的状态来修改中断的状态</span></span><br><span class="line">	<span class="keyword">if</span> (nf-&gt;flags &amp; NETIF_FLAG_UP) &#123;</span><br><span class="line">		<span class="keyword">if</span> (uk_netdev_rxintr_supported(lwip_data-&gt;dev_info.features)) &#123;</span><br><span class="line">			ret = uk_netdev_rxq_intr_enable(dev, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">						(<span class="string">&quot;%s: %c%c%u: Failed to enable rx interrupt mode on netdev %u\n&quot;</span>,</span><br><span class="line">						 __func__, nf-&gt;name[<span class="number">0</span>],</span><br><span class="line">						 nf-&gt;name[<span class="number">1</span>],</span><br><span class="line">						 nf-&gt;num,</span><br><span class="line">						 uk_netdev_id_get(dev)));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">					(<span class="string">&quot;%s: %c%c%u: Enabled rx interrupt mode on netdev %u\n&quot;</span>,</span><br><span class="line">						 __func__, nf-&gt;name[<span class="number">0</span>],</span><br><span class="line">						 nf-&gt;name[<span class="number">1</span>],</span><br><span class="line">						 nf-&gt;num,</span><br><span class="line">						 uk_netdev_id_get(dev)));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 中断开启后调用 poll 函数进行监控</span></span><br><span class="line">				uknetdev_poll(nf);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 若不支持中断则创建线程来执行 poll 操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_SCHED</span></span><br><span class="line">			LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">					(<span class="string">&quot;%s: Poll receive enabled\n&quot;</span>,</span><br><span class="line">					 __func__));</span><br><span class="line">			<span class="comment">/* Create a thread */</span></span><br><span class="line">			lwip_data-&gt;sched = uk_sched_get_default();</span><br><span class="line">			UK_ASSERT(lwip_data-&gt;sched);</span><br><span class="line">			lwip_data-&gt;poll_thread =</span><br><span class="line">				uk_sched_thread_create(lwip_data-&gt;sched, <span class="literal">NULL</span>,</span><br><span class="line">						       <span class="literal">NULL</span>, _poll_netif, nf);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* CONFIG_HAVE_SCHED */</span></span></span><br><span class="line">			uk_pr_warn(<span class="string">&quot;The netdevice does not support interrupt. Ensure the netdevice is polled to receive packets&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HAVE_SCHED */</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 停止网络接口</span></span><br><span class="line">		<span class="keyword">if</span> (uk_netdev_rxintr_supported(lwip_data-&gt;dev_info.features)) &#123;</span><br><span class="line">			uk_netdev_rxq_intr_disable(dev, <span class="number">0</span>);</span><br><span class="line">			LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">					(<span class="string">&quot;%s: %c%c%u: Disabled rx interrupts on netdev %u\n&quot;</span>,</span><br><span class="line">					 __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>],</span><br><span class="line">					 nf-&gt;num, uk_netdev_id_get(dev)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若定义了 <code>CONFIG_LWIP_NOTHREADS</code> 通过 <code>uknetdev_poll_all</code> 来执行 poll 操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uknetdev_poll_all</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">nf</span>;</span></span><br><span class="line">	NETIF_FOREACH(nf) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nf-&gt;name[<span class="number">0</span>] == UKNETDEV_NETIF_NAME0</span><br><span class="line">		    &amp;&amp; nf-&gt;name[<span class="number">1</span>] == UKNETDEV_NETIF_NAME1)</span><br><span class="line">			uknetdev_poll(nf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若未定义则通过 <code>_poll_netif</code> 来执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _poll_netif(<span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">nf</span> =</span> (<span class="keyword">struct</span> netif *) arg;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		uknetdev_poll(nf);</span><br><span class="line">		uk_sched_yield();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uknetdev_poll</span><span class="params">(<span class="keyword">struct</span> netif *nf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netdev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	UK_ASSERT(nf);</span><br><span class="line">	UK_ASSERT(nf-&gt;name[<span class="number">0</span>] == UKNETDEV_NETIF_NAME0);</span><br><span class="line">	UK_ASSERT(nf-&gt;name[<span class="number">1</span>] == UKNETDEV_NETIF_NAME1);</span><br><span class="line">	<span class="comment">// 将 netif 转化为 uk_netdev</span></span><br><span class="line">	dev = netif_to_uknetdev(nf);</span><br><span class="line">	UK_ASSERT(dev);</span><br><span class="line">	<span class="comment">// 进行收包的操作</span></span><br><span class="line">	uknetdev_input(dev, <span class="number">0</span>, nf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="output-执行流程"><a href="#output-执行流程" class="headerlink" title="output 执行流程"></a>output 执行流程</h2><p><img src="/images/unikraft-liblwip/output_stream.svg" alt="output 执行流程"></p>
<p>output 部分的逻辑由于不需要轮询和中断，相对而言会更加简单一些</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">err_t</span> <span class="title function_">uknetdev_output</span><span class="params">(<span class="keyword">struct</span> netif *nf, <span class="keyword">struct</span> pbuf *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netdev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lwip_netdev_data</span> *<span class="title">lwip_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uk_netbuf</span> *<span class="title">nb</span>;</span></span><br><span class="line">	<span class="type">char</span> *wpos;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	UK_ASSERT(nf);</span><br><span class="line">	<span class="comment">// 将 netif 转化为 unikraft 中的 uk_netdev</span></span><br><span class="line">	dev = netif_to_uknetdev(nf);</span><br><span class="line">	UK_ASSERT(dev);</span><br><span class="line">	lwip_data = (<span class="keyword">struct</span> lwip_netdev_data *) dev-&gt;scratch_pad;</span><br><span class="line">	UK_ASSERT(lwip_data);</span><br><span class="line">	<span class="comment">// 分配内存</span></span><br><span class="line">	nb = uk_netbuf_alloc_buf(lwip_data-&gt;pkt_a,</span><br><span class="line">				 UKNETDEV_BUFLEN,</span><br><span class="line">				 lwip_data-&gt;dev_info.ioalign,</span><br><span class="line">				 lwip_data-&gt;dev_info.nb_encap_tx,</span><br><span class="line">				 <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!nb)</span><br><span class="line">		<span class="keyword">return</span> ERR_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(p-&gt;tot_len &gt; uk_netbuf_tailroom(nb))) &#123;</span><br><span class="line">		LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">			    (<span class="string">&quot;%s: %c%c%u: Cannot send %&quot;</span>PRIu16<span class="string">&quot; bytes, too big (&gt; %&quot;</span>__PRIsz<span class="string">&quot;)\n&quot;</span>,</span><br><span class="line">			     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">			     p-&gt;tot_len, uk_netbuf_tailroom(nb)));</span><br><span class="line">		uk_netbuf_free_single(nb);</span><br><span class="line">		<span class="keyword">return</span> ERR_MEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Copy pbuf to netbuf</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">NOTE:</span> Unfortunately, lwIP seems not to support zero-copy transmit,</span></span><br><span class="line"><span class="comment">	 *       yet. As long as we do not have this, we have to copy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 由于目前 lwip 库不支持零复制传输，故需要使用 memcpy 进行复制</span></span><br><span class="line">	wpos = nb-&gt;data;</span><br><span class="line">	<span class="keyword">for</span> (q = p; q != <span class="literal">NULL</span>; q = q-&gt;next) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(wpos, q-&gt;payload, q-&gt;len);</span><br><span class="line">		wpos += q-&gt;len;</span><br><span class="line">	&#125;</span><br><span class="line">	nb-&gt;len = p-&gt;tot_len;</span><br><span class="line">	<span class="comment">// 开始发包，并判断是否仍然有待处理的数据包</span></span><br><span class="line">	<span class="comment">/* Transmit packet */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret = uk_netdev_tx_one(dev, <span class="number">0</span>, nb);</span><br><span class="line">	&#125; <span class="keyword">while</span> (uk_netdev_status_notready(ret));</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		LWIP_DEBUGF(NETIF_DEBUG,</span><br><span class="line">			    (<span class="string">&quot;%s: %c%c%u: Failed to send %&quot;</span>PRIu16<span class="string">&quot; bytes\n&quot;</span>,</span><br><span class="line">			     __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">			     p-&gt;tot_len));</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Decrease refcount again because in</span></span><br><span class="line"><span class="comment">		 * the error case the netdev did not consume the pbuf</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		uk_netbuf_free_single(nb);</span><br><span class="line">		<span class="keyword">return</span> ERR_IF;</span><br><span class="line">	&#125;</span><br><span class="line">	LWIP_DEBUGF(NETIF_DEBUG, (<span class="string">&quot;%s: %c%c%u: Sent %&quot;</span>PRIu16<span class="string">&quot; bytes\n&quot;</span>,</span><br><span class="line">				  __func__, nf-&gt;name[<span class="number">0</span>], nf-&gt;name[<span class="number">1</span>], nf-&gt;num,</span><br><span class="line">				  p-&gt;tot_len));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与用户交互"><a href="#与用户交互" class="headerlink" title="与用户交互"></a>与用户交互</h2><p>前文中提到 unikraft 接入了两套 lwip 的 API，分别是 NETCONN API 和 socket API。socket部分不用多说，用户调用 sys/socket.h 中提供的各种函数即可。下面简单介绍一下用户如何调用 NETCONN API 以及在调用时都发生了什么。</p>
<p>首先，用户需要调用 <code>netconn_new</code> 来新建一个 netconn。<code>netconn_new</code> 本质上是一个宏定义，实际上指向的函数是 <code>netconn_new_with_proto_and_callback</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> netconn_new(t) netconn_new_with_proto_and_callback(t, 0, NULL)</span></span><br></pre></td></tr></table></figure>

<p>在这个函数中会先调用 <code>netconn_alloc</code> 进行分配内存以及初始化的操作，随后调用 <code>netconn_apimsg</code> 函数构造一个消息，并且通过系统的消息邮箱发送给内核线程， 请求LwIP内核去执行 <code>lwip_netconn_do_newconn</code> 函数，并且在执行的时候，需要利用 <code>op_completed</code> 字段的信号量进行同步，直到内核处理完后，会释放一个信号量表示执行完成，这样子就形成两个线程间的同步，<code>netconn_new</code> 函数才得以继续执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> netconn *</span><br><span class="line"><span class="title function_">netconn_new_with_proto_and_callback</span><span class="params">(<span class="keyword">enum</span> netconn_type t, <span class="type">u8_t</span> proto, netconn_callback callback)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netconn</span> *<span class="title">conn</span>;</span></span><br><span class="line">  API_MSG_VAR_DECLARE(msg);</span><br><span class="line">  API_MSG_VAR_ALLOC_RETURN_NULL(msg);</span><br><span class="line">	<span class="comment">// 分配内存及初始化</span></span><br><span class="line">  conn = netconn_alloc(t, callback);</span><br><span class="line">  <span class="keyword">if</span> (conn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">err_t</span> err;</span><br><span class="line"></span><br><span class="line">    API_MSG_VAR_REF(msg).msg.n.proto = proto;</span><br><span class="line">    API_MSG_VAR_REF(msg).conn = conn;</span><br><span class="line">    err = netconn_apimsg(lwip_netconn_do_newconn, &amp;API_MSG_VAR_REF(msg));</span><br><span class="line">    <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;freeing conn without freeing pcb&quot;</span>, conn-&gt;pcb.tcp == <span class="literal">NULL</span>);</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;conn has no recvmbox&quot;</span>, sys_mbox_valid(&amp;conn-&gt;recvmbox));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;conn-&gt;acceptmbox shouldn&#x27;t exist&quot;</span>, !sys_mbox_valid(&amp;conn-&gt;acceptmbox));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !LWIP_NETCONN_SEM_PER_THREAD</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;conn has no op_completed&quot;</span>, sys_sem_valid(&amp;conn-&gt;op_completed));</span><br><span class="line">      sys_sem_free(&amp;conn-&gt;op_completed);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !LWIP_NETCONN_SEM_PER_THREAD */</span></span></span><br><span class="line">      sys_mbox_free(&amp;conn-&gt;recvmbox);</span><br><span class="line">      memp_free(MEMP_NETCONN, conn);</span><br><span class="line">      API_MSG_VAR_FREE(msg);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  API_MSG_VAR_FREE(msg);</span><br><span class="line">  <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> netconn *</span><br><span class="line"><span class="title function_">netconn_alloc</span><span class="params">(<span class="keyword">enum</span> netconn_type t, netconn_callback callback)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netconn</span> *<span class="title">conn</span>;</span></span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">u8_t</span> init_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 分配内存</span></span><br><span class="line">  conn = (<span class="keyword">struct</span> netconn *)memp_malloc(MEMP_NETCONN);</span><br><span class="line">  <span class="keyword">if</span> (conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  conn-&gt;pending_err = ERR_OK;</span><br><span class="line">  conn-&gt;type = t;</span><br><span class="line">  conn-&gt;pcb.tcp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETCONN_FULLDUPLEX</span></span><br><span class="line">  conn-&gt;mbox_threads_waiting = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If all sizes are the same, every compiler should optimize this switch to nothing */</span></span><br><span class="line">  <span class="keyword">switch</span> (NETCONNTYPE_GROUP(t)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_RAW</span></span><br><span class="line">    <span class="keyword">case</span> NETCONN_RAW:</span><br><span class="line">      size = DEFAULT_RAW_RECVMBOX_SIZE;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_RAW */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_UDP</span></span><br><span class="line">    <span class="keyword">case</span> NETCONN_UDP:</span><br><span class="line">      size = DEFAULT_UDP_RECVMBOX_SIZE;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETBUF_RECVINFO</span></span><br><span class="line">      init_flags |= NETCONN_FLAG_PKTINFO;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETBUF_RECVINFO */</span></span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_UDP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line">    <span class="keyword">case</span> NETCONN_TCP:</span><br><span class="line">      size = DEFAULT_TCP_RECVMBOX_SIZE;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;netconn_alloc: undefined netconn_type&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">goto</span> free_and_return;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 新建信箱以及信号量</span></span><br><span class="line">  <span class="keyword">if</span> (sys_mbox_new(&amp;conn-&gt;recvmbox, size) != ERR_OK) &#123;</span><br><span class="line">    <span class="keyword">goto</span> free_and_return;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !LWIP_NETCONN_SEM_PER_THREAD</span></span><br><span class="line">  <span class="keyword">if</span> (sys_sem_new(&amp;conn-&gt;op_completed, <span class="number">0</span>) != ERR_OK) &#123;</span><br><span class="line">    sys_mbox_free(&amp;conn-&gt;recvmbox);</span><br><span class="line">    <span class="keyword">goto</span> free_and_return;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line">  sys_mbox_set_invalid(&amp;conn-&gt;acceptmbox);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  conn-&gt;state        = NETCONN_NONE;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SOCKET</span></span><br><span class="line">  <span class="comment">/* initialize socket to -1 since 0 is a valid socket */</span></span><br><span class="line">  conn-&gt;socket       = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_SOCKET */</span></span></span><br><span class="line">  conn-&gt;callback     = callback;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line">  conn-&gt;current_msg  = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SO_SNDTIMEO</span></span><br><span class="line">  conn-&gt;send_timeout = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_SO_SNDTIMEO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SO_RCVTIMEO</span></span><br><span class="line">  conn-&gt;recv_timeout = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_SO_RCVTIMEO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SO_RCVBUF</span></span><br><span class="line">  conn-&gt;recv_bufsize = RECV_BUFSIZE_DEFAULT;</span><br><span class="line">  conn-&gt;recv_avail   = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_SO_RCVBUF */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SO_LINGER</span></span><br><span class="line">  conn-&gt;linger = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_SO_LINGER */</span></span></span><br><span class="line">  conn-&gt;flags = init_flags;</span><br><span class="line">  <span class="keyword">return</span> conn;</span><br><span class="line">free_and_return:</span><br><span class="line">  memp_free(MEMP_NETCONN, conn);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 netconn_new 相对应的就是 netconn_delete。对于 TCP 连接， 如果此时是处于连接状态的，在调用该函数后，将请求内核执行终止连接操作，此时应用线程是无需理会到底是怎么运作的， 因为 lwip 内核将会完成所有的挥手过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">netconn_delete</span><span class="params">(<span class="keyword">struct</span> netconn *conn)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */</span></span><br><span class="line">  <span class="keyword">if</span> (conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_NETCONN_FULLDUPLEX</span></span><br><span class="line">  <span class="keyword">if</span> (conn-&gt;flags &amp; NETCONN_FLAG_MBOXINVALID) &#123;</span><br><span class="line">    <span class="comment">/* Already called netconn_prepare_delete() before */</span></span><br><span class="line">    err = ERR_OK;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_NETCONN_FULLDUPLEX */</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    err = netconn_prepare_delete(conn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">    netconn_free(conn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处与新建 netconn 相对应，调用 <code>lwip_netconn_do_delconn</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">netconn_prepare_delete</span><span class="params">(<span class="keyword">struct</span> netconn *conn)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line">  API_MSG_VAR_DECLARE(msg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */</span></span><br><span class="line">  <span class="keyword">if</span> (conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  API_MSG_VAR_ALLOC(msg);</span><br><span class="line">  API_MSG_VAR_REF(msg).conn = conn;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SO_SNDTIMEO || LWIP_SO_LINGER</span></span><br><span class="line">  <span class="comment">/* get the time we started, which is later compared to</span></span><br><span class="line"><span class="comment">     sys_now() + conn-&gt;send_timeout */</span></span><br><span class="line">  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */</span></span></span><br><span class="line">  API_MSG_VAR_REF(msg).msg.sd.polls_left =</span><br><span class="line">    ((LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT + TCP_SLOW_INTERVAL - <span class="number">1</span>) / TCP_SLOW_INTERVAL) + <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line">  err = netconn_apimsg(lwip_netconn_do_delconn, &amp;API_MSG_VAR_REF(msg));</span><br><span class="line">  API_MSG_VAR_FREE(msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netconn_getaddr</code> 函数的作用很简单，就是获取一个 netconn 连接结构的源 IP 地址、端口号与目标IP地址、端口号等信息， 并且 IP 地址保存在 addr 中，端口号保存在 port 中，而 local 指定需要获取的信息是本地IP地址（源 IP 地址） 还是远端 IP 地址（目标 IP 地址），如果是 1 则表示获取本地 IP 地址与端口号，如果为 0 表示远端 IP 地址与端口号。 同样的，该函数会调用 <code>netconn_apimsg</code> 函数构造一个 API 消息，并且请求内核执行<code>lwip_netconn_do_getaddr</code> 函数， 然后通过 netconn 连接结构的信号量进行同步。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">netconn_getaddr</span><span class="params">(<span class="keyword">struct</span> netconn *conn, <span class="type">ip_addr_t</span> *addr, <span class="type">u16_t</span> *port, <span class="type">u8_t</span> local)</span></span><br><span class="line">&#123;</span><br><span class="line">  API_MSG_VAR_DECLARE(msg);</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_getaddr: invalid conn&quot;</span>, (conn != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_getaddr: invalid addr&quot;</span>, (addr != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_getaddr: invalid port&quot;</span>, (port != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line"></span><br><span class="line">  API_MSG_VAR_ALLOC(msg);</span><br><span class="line">  API_MSG_VAR_REF(msg).conn = conn;</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.ad.local = local;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_MPU_COMPATIBLE</span></span><br><span class="line">  err = netconn_apimsg(lwip_netconn_do_getaddr, &amp;API_MSG_VAR_REF(msg));</span><br><span class="line">  *addr = msg-&gt;msg.ad.ipaddr;</span><br><span class="line">  *port = msg-&gt;msg.ad.port;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* LWIP_MPU_COMPATIBLE */</span></span></span><br><span class="line">  msg.msg.ad.ipaddr = addr;</span><br><span class="line">  msg.msg.ad.port = port;</span><br><span class="line">  err = netconn_apimsg(lwip_netconn_do_getaddr, &amp;msg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_MPU_COMPATIBLE */</span></span></span><br><span class="line">  API_MSG_VAR_FREE(msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netconn_bind</code> 函数用于将一个 IP 地址及端口号与 netconn 连接结构进行绑定，如果作为服务器端，这一步操作是必然需要的，同样的， 该函数会调用 <code>netconn_apimsg</code> 函数构造一个API 消息，并且请求内核执行 <code>lwip_netconn_do_bind</code> 函数， 然后通过 netconn 连接结构的信号量进行同步，事实上内核线程的处理也是通过函数调用 xxx_bind（ xxx_bind 可以是udp_bind、tcp_bind、raw_bind，具体是哪个函数内核是根据 netconn 的类型决定的） 完成相应控制块的绑定工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">netconn_bind</span><span class="params">(<span class="keyword">struct</span> netconn *conn, <span class="type">const</span> <span class="type">ip_addr_t</span> *addr, <span class="type">u16_t</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">  API_MSG_VAR_DECLARE(msg);</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_bind: invalid conn&quot;</span>, (conn != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">  <span class="comment">/* Don&#x27;t propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */</span></span><br><span class="line">  <span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    addr = IP4_ADDR_ANY;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4 &amp;&amp; LWIP_IPV6</span></span><br><span class="line">  <span class="comment">/* &quot;Socket API like&quot; dual-stack support: If IP to bind to is IP6_ADDR_ANY,</span></span><br><span class="line"><span class="comment">   * and NETCONN_FLAG_IPV6_V6ONLY is 0, use IP_ANY_TYPE to bind</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ((netconn_get_ipv6only(conn) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">      ip_addr_cmp(addr, IP6_ADDR_ANY)) &#123;</span><br><span class="line">    addr = IP_ANY_TYPE;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 &amp;&amp; LWIP_IPV6 */</span></span></span><br><span class="line"></span><br><span class="line">  API_MSG_VAR_ALLOC(msg);</span><br><span class="line">  API_MSG_VAR_REF(msg).conn = conn;</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.bc.port = port;</span><br><span class="line">  err = netconn_apimsg(lwip_netconn_do_bind, &amp;API_MSG_VAR_REF(msg));</span><br><span class="line">  API_MSG_VAR_FREE(msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netconn_connect</code> 函数是一个主动建立连接的函数，它一般在客户端中调用，将服务器端的 IP 地址和端口号与本地的 netconn 连接结构绑定，当 TCP 协议使用该函数的时候就是进行握手的过程，调用的应用线程将阻塞至握手完成； 而对于 UDP 协议来说，调用该函数只是设置 UDP 控制块的目标 IP 地址与目标端口号， 其实这个函数也是通过调用<code>netconn_apimsg</code> 函数构造一个API消息，并且请求内核执行 <code>lwip_netconn_do_connect</code> 函数， 然后通过 netconn 连接结构的信号量进行同步，在 <code>lwip_netconn_do_connect</code> 函数中，根据 netconn 的类型不同， 调用对应的 xxx_connect 函数进行对应的处理，如果是 TCP连接，将调用 <code>tcp_connect</code>；如果是 UDP 协议， 将调用 <code>udp_connect</code>；如果是 RAW，将调用 <code>raw_connect</code> 函数处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">netconn_connect</span><span class="params">(<span class="keyword">struct</span> netconn *conn, <span class="type">const</span> <span class="type">ip_addr_t</span> *addr, <span class="type">u16_t</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">  API_MSG_VAR_DECLARE(msg);</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_connect: invalid conn&quot;</span>, (conn != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_IPV4</span></span><br><span class="line">  <span class="comment">/* Don&#x27;t propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */</span></span><br><span class="line">  <span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    addr = IP4_ADDR_ANY;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV4 */</span></span></span><br><span class="line"></span><br><span class="line">  API_MSG_VAR_ALLOC(msg);</span><br><span class="line">  API_MSG_VAR_REF(msg).conn = conn;</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.bc.port = port;</span><br><span class="line">  err = netconn_apimsg(lwip_netconn_do_connect, &amp;API_MSG_VAR_REF(msg));</span><br><span class="line">  API_MSG_VAR_FREE(msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数是用于终止一个 UDP 协议的通信，简单来说就是将UDP控制块的目标IP地址与目标端口号清除， 同样的该函数也是构造API消息请求内核执行 <code>lwip_netconn_do_disconnect</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">netconn_disconnect</span><span class="params">(<span class="keyword">struct</span> netconn *conn)</span></span><br><span class="line">&#123;</span><br><span class="line">  API_MSG_VAR_DECLARE(msg);</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_disconnect: invalid conn&quot;</span>, (conn != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line"></span><br><span class="line">  API_MSG_VAR_ALLOC(msg);</span><br><span class="line">  API_MSG_VAR_REF(msg).conn = conn;</span><br><span class="line">  err = netconn_apimsg(lwip_netconn_do_disconnect, &amp;API_MSG_VAR_REF(msg));</span><br><span class="line">  API_MSG_VAR_FREE(msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netconn_listen</code> 函数的本质是一个带参宏，其真正调用的函数是<code>netconn_listen_with_backlog</code>， 只适用于 TCP 服务器中调用，它的作用是让 netconn 连接结构处于监听状态，同时让 TCP 控制块的状态处于 LISTEN 状态， 以便客户端连接，同样的，它通过 <code>netconn_apimsg</code> 函数请求内核执行 <code>lwip_netconn_do_listen</code>， 这个函数才是真正处理 TCP 连接的监听状态，并且在这个函数中会创建一个连接邮箱—— <code>acceptmbox</code>  邮箱在 netconn 连接结构中， 然后在TCP控制块中注册连接回调函数—— <code>accept_function</code>，当有客户端连接的时候，这个回调函数被执行， 并且向 <code>acceptmbox</code> 邮箱发送一个消息，通知应用程序有一个新的客户端连接，以便用户去处理这个连接。当然， 在<code>wip_netconn_do_listen</code> 函数处理完成的时候会释放一个信号量，以进行线程间的同步。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">netconn_listen_with_backlog</span><span class="params">(<span class="keyword">struct</span> netconn *conn, <span class="type">u8_t</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line">  API_MSG_VAR_DECLARE(msg);</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */</span></span><br><span class="line">  LWIP_UNUSED_ARG(backlog);</span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_listen: invalid conn&quot;</span>, (conn != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line"></span><br><span class="line">  API_MSG_VAR_ALLOC(msg);</span><br><span class="line">  API_MSG_VAR_REF(msg).conn = conn;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_LISTEN_BACKLOG</span></span><br><span class="line">  API_MSG_VAR_REF(msg).msg.lb.backlog = backlog;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_LISTEN_BACKLOG */</span></span></span><br><span class="line">  err = netconn_apimsg(lwip_netconn_do_listen, &amp;API_MSG_VAR_REF(msg));</span><br><span class="line">  API_MSG_VAR_FREE(msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line">  LWIP_UNUSED_ARG(conn);</span><br><span class="line">  LWIP_UNUSED_ARG(backlog);</span><br><span class="line">  <span class="keyword">return</span> ERR_ARG;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数可以接收一个UDP或者TCP的数据包，从 <code>recvmbox</code> 邮箱中获取数据包，如果该邮箱中没有数据包，那么线程调用这个函数将会进入阻塞状态以等待消息的到来，如果在等待 TCP 连接上的数据时，远端主机终止连接，将返回一个终止连接的错误代码（ERR_CLSD），应用程序可以根据错误的类型进行不一样的处理。</p>
<p>对应TCP连接，<code>netconn_recv</code> 函数将调用 <code>netconn_recv_data_tcp</code> 函数去获取 TCP 连接上的数据， 在获取数据的过程中，调用 <code>netconn_recv_data</code> 函数从 <code>recvmbox</code> 邮箱获取 pbuf， 然后通过 <code>netconn_tcp_recvd_msg-&gt;netconn_apimsg</code> 函数构造一个 API 消息投递给系统邮箱， 请求内核执行 <code>lwip_netconn_do_recv</code> 函数，该函数将调用 <code>tcp_recved</code> 函数去更新 TCP 接收窗口， 同时 <code>netconn_recv</code> 函数将完成 pbuf 数据包封装在 netbuf 中，返回给应用程序；而对于 UDP 协议和 RAW 连接将直接调用 <code>netconn_recv_data</code> 函数获取数据，完成 pbuf 封装在 netbuf 中， 返回给应用程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">netconn_recv</span><span class="params">(<span class="keyword">struct</span> netconn *conn, <span class="keyword">struct</span> netbuf **new_buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netbuf</span> *<span class="title">buf</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_recv: invalid pointer&quot;</span>, (new_buf != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line">  *new_buf = <span class="literal">NULL</span>;</span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_recv: invalid conn&quot;</span>,    (conn != <span class="literal">NULL</span>),    <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LWIP_UDP || LWIP_RAW)</span></span><br><span class="line">  <span class="keyword">if</span> (NETCONNTYPE_GROUP(conn-&gt;type) == NETCONN_TCP)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* (LWIP_UDP || LWIP_RAW) */</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* This is not a listening netconn, since recvmbox is set */</span></span><br><span class="line"></span><br><span class="line">    buf = (<span class="keyword">struct</span> netbuf *)memp_malloc(MEMP_NETBUF);</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ERR_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = netconn_recv_data_tcp(conn, &amp;p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">      memp_free(MEMP_NETBUF, buf);</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p != NULL&quot;</span>, p != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    buf-&gt;p = p;</span><br><span class="line">    buf-&gt;ptr = p;</span><br><span class="line">    buf-&gt;port = <span class="number">0</span>;</span><br><span class="line">    ip_addr_set_zero(&amp;buf-&gt;addr);</span><br><span class="line">    *new_buf = buf;</span><br><span class="line">    <span class="comment">/* don&#x27;t set conn-&gt;last_err: it&#x27;s only ERR_OK, anyway */</span></span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP &amp;&amp; (LWIP_UDP || LWIP_RAW)</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP &amp;&amp; (LWIP_UDP || LWIP_RAW) */</span></span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LWIP_UDP || LWIP_RAW)</span></span><br><span class="line">    <span class="keyword">return</span> netconn_recv_data(conn, (<span class="type">void</span> **)new_buf, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* (LWIP_UDP || LWIP_RAW) */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这个函数就和我们之前分析的流程成功串接在了一起</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tcp_recved</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="type">u16_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u32_t</span> wnd_inflation;</span><br><span class="line">  <span class="type">tcpwnd_size_t</span> rcv_wnd;</span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT_CORE_LOCKED();</span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;tcp_recved: invalid pcb&quot;</span>, pcb != <span class="literal">NULL</span>, <span class="keyword">return</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pcb-&gt;state LISTEN not allowed here */</span></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;don&#x27;t call tcp_recved for listen-pcbs&quot;</span>,</span><br><span class="line">              pcb-&gt;state != LISTEN);</span><br><span class="line"></span><br><span class="line">  rcv_wnd = (<span class="type">tcpwnd_size_t</span>)(pcb-&gt;rcv_wnd + len);</span><br><span class="line">  <span class="keyword">if</span> ((rcv_wnd &gt; TCP_WND_MAX(pcb)) || (rcv_wnd &lt; pcb-&gt;rcv_wnd)) &#123;</span><br><span class="line">    <span class="comment">/* window got too big or tcpwnd_size_t overflow */</span></span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_recved: window got too big or tcpwnd_size_t overflow\n&quot;</span>));</span><br><span class="line">    pcb-&gt;rcv_wnd = TCP_WND_MAX(pcb);</span><br><span class="line">  &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">    pcb-&gt;rcv_wnd = rcv_wnd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the change in the right edge of window is significant (default</span></span><br><span class="line"><span class="comment">   * watermark is TCP_WND/4), then send an explicit update now.</span></span><br><span class="line"><span class="comment">   * Otherwise wait for a packet to be sent in the normal course of</span></span><br><span class="line"><span class="comment">   * events (or more window to be available later) */</span></span><br><span class="line">  <span class="keyword">if</span> (wnd_inflation &gt;= TCP_WND_UPDATE_THRESHOLD) &#123;</span><br><span class="line">    tcp_ack_now(pcb);</span><br><span class="line">    tcp_output(pcb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_recved: received %&quot;</span>U16_F<span class="string">&quot; bytes, wnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot; (%&quot;</span>TCPWNDSIZE_F<span class="string">&quot;).\n&quot;</span>,</span><br><span class="line">                          len, pcb-&gt;rcv_wnd, (<span class="type">u16_t</span>)(TCP_WND_MAX(pcb) - pcb-&gt;rcv_wnd)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>netconn_write()函数的本质是一个宏，用于处于稳定连接状态的TCP协议发送数据，TCP协议的数据是以流的方式传输的，只需要指出发送数据的其实地址与长度即可，LwIP内核会帮我们直接处理这些数据，将这些数据按字节流进行编号，让它们按照TCP协议的方式进行传输，这样子就无需我们理会怎么传输了，对于数据的长度也没限制，内核会直接处理，使得它们变成最适的方式发送出去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">netconn_write_vectors_partly</span><span class="params">(<span class="keyword">struct</span> netconn *conn, <span class="keyword">struct</span> netvector *vectors, <span class="type">u16_t</span> vectorcnt,</span></span><br><span class="line"><span class="params">                             <span class="type">u8_t</span> apiflags, <span class="type">size_t</span> *bytes_written)</span></span><br><span class="line">&#123;</span><br><span class="line">  API_MSG_VAR_DECLARE(msg);</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line">  <span class="type">u8_t</span> dontblock;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_write: invalid conn&quot;</span>,  (conn != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_write: invalid conn-&gt;type&quot;</span>,  (NETCONNTYPE_GROUP(conn-&gt;type) == NETCONN_TCP), <span class="keyword">return</span> ERR_VAL;);</span><br><span class="line">  dontblock = netconn_is_nonblocking(conn) || (apiflags &amp; NETCONN_DONTBLOCK);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SO_SNDTIMEO</span></span><br><span class="line">  <span class="keyword">if</span> (conn-&gt;send_timeout != <span class="number">0</span>) &#123;</span><br><span class="line">    dontblock = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_SO_SNDTIMEO */</span></span></span><br><span class="line">  <span class="keyword">if</span> (dontblock &amp;&amp; !bytes_written) &#123;</span><br><span class="line">    <span class="comment">/* This implies netconn_write() cannot be used for non-blocking send, since</span></span><br><span class="line"><span class="comment">       it has no way to return the number of bytes written. */</span></span><br><span class="line">    <span class="keyword">return</span> ERR_VAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* sum up the total size */</span></span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vectorcnt; i++) &#123;</span><br><span class="line">    size += vectors[i].len;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; vectors[i].len) &#123;</span><br><span class="line">      <span class="comment">/* overflow */</span></span><br><span class="line">      <span class="keyword">return</span> ERR_VAL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; SSIZE_MAX) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> limited;</span><br><span class="line">    <span class="comment">/* this is required by the socket layer (cannot send full size_t range) */</span></span><br><span class="line">    <span class="keyword">if</span> (!bytes_written) &#123;</span><br><span class="line">      <span class="keyword">return</span> ERR_VAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* limit the amount of data to send */</span></span><br><span class="line">    limited = SSIZE_MAX;</span><br><span class="line">    size = (<span class="type">size_t</span>)limited;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  API_MSG_VAR_ALLOC(msg);</span><br><span class="line">  <span class="comment">/* non-blocking write sends as much  */</span></span><br><span class="line">  API_MSG_VAR_REF(msg).conn = conn;</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.w.<span class="built_in">vector</span> = vectors;</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.w.vector_cnt = vectorcnt;</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.w.vector_off = <span class="number">0</span>;</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.w.apiflags = apiflags;</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.w.len = size;</span><br><span class="line">  API_MSG_VAR_REF(msg).msg.w.offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SO_SNDTIMEO</span></span><br><span class="line">  <span class="keyword">if</span> (conn-&gt;send_timeout != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* get the time we started, which is later compared to</span></span><br><span class="line"><span class="comment">        sys_now() + conn-&gt;send_timeout */</span></span><br><span class="line">    API_MSG_VAR_REF(msg).msg.w.time_started = sys_now();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    API_MSG_VAR_REF(msg).msg.w.time_started = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_SO_SNDTIMEO */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For locking the core: this _can_ be delayed on low memory/low send buffer,</span></span><br><span class="line"><span class="comment">     but if it is, this is done inside api_msg.c:do_write(), so we can use the</span></span><br><span class="line"><span class="comment">     non-blocking version here. */</span></span><br><span class="line">  err = netconn_apimsg(lwip_netconn_do_write, &amp;API_MSG_VAR_REF(msg));</span><br><span class="line">  <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bytes_written != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      *bytes_written = API_MSG_VAR_REF(msg).msg.w.offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* for blocking, check all requested bytes were written, <span class="doctag">NOTE:</span> send_timeout is</span></span><br><span class="line"><span class="comment">       treated as dontblock (see dontblock assignment above) */</span></span><br><span class="line">    <span class="keyword">if</span> (!dontblock) &#123;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;do_write failed to write all bytes&quot;</span>, API_MSG_VAR_REF(msg).msg.w.offset == size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  API_MSG_VAR_FREE(msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">lwip_netconn_do_write</span><span class="params">(<span class="type">void</span> *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">api_msg</span> *<span class="title">msg</span> =</span> (<span class="keyword">struct</span> api_msg *)m;</span><br><span class="line"></span><br><span class="line">  <span class="type">err_t</span> err = netconn_err(msg-&gt;conn);</span><br><span class="line">  <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (NETCONNTYPE_GROUP(msg-&gt;conn-&gt;type) == NETCONN_TCP) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line">      <span class="keyword">if</span> (msg-&gt;conn-&gt;state != NETCONN_NONE) &#123;</span><br><span class="line">        <span class="comment">/* netconn is connecting, closing or in blocking write */</span></span><br><span class="line">        err = ERR_INPROGRESS;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;conn-&gt;pcb.tcp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;conn-&gt;state = NETCONN_WRITE;</span><br><span class="line">        <span class="comment">/* set all the variables used by lwip_netconn_do_writemore */</span></span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;already writing or closing&quot;</span>, msg-&gt;conn-&gt;current_msg == <span class="literal">NULL</span>);</span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;msg-&gt;msg.w.len != 0&quot;</span>, msg-&gt;msg.w.len != <span class="number">0</span>);</span><br><span class="line">        msg-&gt;conn-&gt;current_msg = msg;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCPIP_CORE_LOCKING</span></span><br><span class="line">        <span class="keyword">if</span> (lwip_netconn_do_writemore(msg-&gt;conn, <span class="number">0</span>) != ERR_OK) &#123;</span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;state!&quot;</span>, msg-&gt;conn-&gt;state == NETCONN_WRITE);</span><br><span class="line">          UNLOCK_TCPIP_CORE();</span><br><span class="line">          sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), <span class="number">0</span>);</span><br><span class="line">          LOCK_TCPIP_CORE();</span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;state!&quot;</span>, msg-&gt;conn-&gt;state != NETCONN_WRITE);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* LWIP_TCPIP_CORE_LOCKING */</span></span></span><br><span class="line">        lwip_netconn_do_writemore(msg-&gt;conn);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCPIP_CORE_LOCKING */</span></span></span><br><span class="line">        <span class="comment">/* for both cases: if lwip_netconn_do_writemore was called, don&#x27;t ACK the APIMSG</span></span><br><span class="line"><span class="comment">           since lwip_netconn_do_writemore ACKs it! */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = ERR_CONN;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line">      err = ERR_VAL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LWIP_UDP || LWIP_RAW)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      err = ERR_VAL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* (LWIP_UDP || LWIP_RAW) */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  msg-&gt;err = err;</span><br><span class="line">  TCPIP_APIMSG_ACK(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">err_t</span></span><br><span class="line"><span class="title function_">lwip_netconn_do_writemore</span><span class="params">(<span class="keyword">struct</span> netconn *conn  WRITE_DELAYED_PARAM)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *dataptr;</span><br><span class="line">  <span class="type">u16_t</span> len, available;</span><br><span class="line">  <span class="type">u8_t</span> write_finished = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> diff;</span><br><span class="line">  <span class="type">u8_t</span> dontblock;</span><br><span class="line">  <span class="type">u8_t</span> apiflags;</span><br><span class="line">  <span class="type">u8_t</span> write_more;</span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;conn != NULL&quot;</span>, conn != <span class="literal">NULL</span>);</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;conn-&gt;state == NETCONN_WRITE&quot;</span>, (conn-&gt;state == NETCONN_WRITE));</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;conn-&gt;current_msg != NULL&quot;</span>, conn-&gt;current_msg != <span class="literal">NULL</span>);</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;conn-&gt;pcb.tcp != NULL&quot;</span>, conn-&gt;pcb.tcp != <span class="literal">NULL</span>);</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;conn-&gt;current_msg-&gt;msg.w.offset &lt; conn-&gt;current_msg-&gt;msg.w.len&quot;</span>,</span><br><span class="line">              conn-&gt;current_msg-&gt;msg.w.offset &lt; conn-&gt;current_msg-&gt;msg.w.len);</span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;conn-&gt;current_msg-&gt;msg.w.vector_cnt &gt; 0&quot;</span>, conn-&gt;current_msg-&gt;msg.w.vector_cnt &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  apiflags = conn-&gt;current_msg-&gt;msg.w.apiflags;</span><br><span class="line">  dontblock = netconn_is_nonblocking(conn) || (apiflags &amp; NETCONN_DONTBLOCK);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SO_SNDTIMEO</span></span><br><span class="line">  <span class="keyword">if</span> ((conn-&gt;send_timeout != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">      ((<span class="type">s32_t</span>)(sys_now() - conn-&gt;current_msg-&gt;msg.w.time_started) &gt;= conn-&gt;send_timeout)) &#123;</span><br><span class="line">    write_finished = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;current_msg-&gt;msg.w.offset == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* nothing has been written */</span></span><br><span class="line">      err = ERR_WOULDBLOCK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* partial write */</span></span><br><span class="line">      err = ERR_OK;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_SO_SNDTIMEO */</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      dataptr = (<span class="type">const</span> <span class="type">u8_t</span> *)conn-&gt;current_msg-&gt;msg.w.<span class="built_in">vector</span>-&gt;ptr + conn-&gt;current_msg-&gt;msg.w.vector_off;</span><br><span class="line">      diff = conn-&gt;current_msg-&gt;msg.w.<span class="built_in">vector</span>-&gt;len - conn-&gt;current_msg-&gt;msg.w.vector_off;</span><br><span class="line">      <span class="keyword">if</span> (diff &gt; <span class="number">0xffff</span>UL) &#123; <span class="comment">/* max_u16_t */</span></span><br><span class="line">        len = <span class="number">0xffff</span>;</span><br><span class="line">        apiflags |= TCP_WRITE_FLAG_MORE;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        len = (<span class="type">u16_t</span>)diff;</span><br><span class="line">      &#125;</span><br><span class="line">      available = tcp_sndbuf(conn-&gt;pcb.tcp);</span><br><span class="line">      <span class="keyword">if</span> (available &lt; len) &#123;</span><br><span class="line">        <span class="comment">/* don&#x27;t try to write more than sendbuf */</span></span><br><span class="line">        len = available;</span><br><span class="line">        <span class="keyword">if</span> (dontblock) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">            <span class="comment">/* set error according to partial write or not */</span></span><br><span class="line">            err = (conn-&gt;current_msg-&gt;msg.w.offset == <span class="number">0</span>) ? ERR_WOULDBLOCK : ERR_OK;</span><br><span class="line">            <span class="keyword">goto</span> err_mem;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          apiflags |= TCP_WRITE_FLAG_MORE;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;lwip_netconn_do_writemore: invalid length!&quot;</span>,</span><br><span class="line">                  ((conn-&gt;current_msg-&gt;msg.w.vector_off + len) &lt;= conn-&gt;current_msg-&gt;msg.w.<span class="built_in">vector</span>-&gt;len));</span><br><span class="line">      <span class="comment">/* we should loop around for more sending in the following cases:</span></span><br><span class="line"><span class="comment">           1) We couldn&#x27;t finish the current vector because of 16-bit size limitations.</span></span><br><span class="line"><span class="comment">              tcp_write() and tcp_sndbuf() both are limited to 16-bit sizes</span></span><br><span class="line"><span class="comment">           2) We are sending the remainder of the current vector and have more */</span></span><br><span class="line">      <span class="keyword">if</span> ((len == <span class="number">0xffff</span> &amp;&amp; diff &gt; <span class="number">0xffff</span>UL) ||</span><br><span class="line">          (len == (<span class="type">u16_t</span>)diff &amp;&amp; conn-&gt;current_msg-&gt;msg.w.vector_cnt &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        write_more = <span class="number">1</span>;</span><br><span class="line">        apiflags |= TCP_WRITE_FLAG_MORE;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write_more = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      err = tcp_write(conn-&gt;pcb.tcp, dataptr, len, apiflags);</span><br><span class="line">      <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">        conn-&gt;current_msg-&gt;msg.w.offset += len;</span><br><span class="line">        conn-&gt;current_msg-&gt;msg.w.vector_off += len;</span><br><span class="line">        <span class="comment">/* check if current vector is finished */</span></span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;current_msg-&gt;msg.w.vector_off == conn-&gt;current_msg-&gt;msg.w.<span class="built_in">vector</span>-&gt;len) &#123;</span><br><span class="line">          conn-&gt;current_msg-&gt;msg.w.vector_cnt--;</span><br><span class="line">          <span class="comment">/* if we have additional vectors, move on to them */</span></span><br><span class="line">          <span class="keyword">if</span> (conn-&gt;current_msg-&gt;msg.w.vector_cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            conn-&gt;current_msg-&gt;msg.w.<span class="built_in">vector</span>++;</span><br><span class="line">            conn-&gt;current_msg-&gt;msg.w.vector_off = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (write_more &amp;&amp; err == ERR_OK);</span><br><span class="line">    <span class="comment">/* if OK or memory error, check available space */</span></span><br><span class="line">    <span class="keyword">if</span> ((err == ERR_OK) || (err == ERR_MEM)) &#123;</span><br><span class="line">err_mem:</span><br><span class="line">      <span class="keyword">if</span> (dontblock &amp;&amp; (conn-&gt;current_msg-&gt;msg.w.offset &lt; conn-&gt;current_msg-&gt;msg.w.len)) &#123;</span><br><span class="line">        <span class="comment">/* non-blocking write did not write everything: mark the pcb non-writable</span></span><br><span class="line"><span class="comment">           and let poll_tcp check writable space to mark the pcb writable again */</span></span><br><span class="line">        API_EVENT(conn, NETCONN_EVT_SENDMINUS, <span class="number">0</span>);</span><br><span class="line">        conn-&gt;flags |= NETCONN_FLAG_CHECK_WRITESPACE;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((tcp_sndbuf(conn-&gt;pcb.tcp) &lt;= TCP_SNDLOWAT) ||</span><br><span class="line">                 (tcp_sndqueuelen(conn-&gt;pcb.tcp) &gt;= TCP_SNDQUEUELOWAT)) &#123;</span><br><span class="line">        <span class="comment">/* The queued byte- or pbuf-count exceeds the configured low-water limit,</span></span><br><span class="line"><span class="comment">           let select mark this pcb as non-writable. */</span></span><br><span class="line">        API_EVENT(conn, NETCONN_EVT_SENDMINUS, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">      <span class="type">err_t</span> out_err;</span><br><span class="line">      <span class="keyword">if</span> ((conn-&gt;current_msg-&gt;msg.w.offset == conn-&gt;current_msg-&gt;msg.w.len) || dontblock) &#123;</span><br><span class="line">        <span class="comment">/* return sent length (caller reads length from msg.w.offset) */</span></span><br><span class="line">        write_finished = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      out_err = tcp_output(conn-&gt;pcb.tcp);</span><br><span class="line">      <span class="keyword">if</span> (out_err == ERR_RTE) &#123;</span><br><span class="line">        <span class="comment">/* If tcp_output fails because no route is found,</span></span><br><span class="line"><span class="comment">           don&#x27;t try writing any more but return the error</span></span><br><span class="line"><span class="comment">           to the application thread. */</span></span><br><span class="line">        err = out_err;</span><br><span class="line">        write_finished = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == ERR_MEM) &#123;</span><br><span class="line">      <span class="comment">/* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called.</span></span><br><span class="line"><span class="comment">         For blocking sockets, we do NOT return to the application</span></span><br><span class="line"><span class="comment">         thread, since ERR_MEM is only a temporary error! Non-blocking</span></span><br><span class="line"><span class="comment">         will remain non-writable until sent_tcp/poll_tcp is called */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* tcp_write returned ERR_MEM, try tcp_output anyway */</span></span><br><span class="line">      <span class="type">err_t</span> out_err = tcp_output(conn-&gt;pcb.tcp);</span><br><span class="line">      <span class="keyword">if</span> (out_err == ERR_RTE) &#123;</span><br><span class="line">        <span class="comment">/* If tcp_output fails because no route is found,</span></span><br><span class="line"><span class="comment">           don&#x27;t try writing any more but return the error</span></span><br><span class="line"><span class="comment">           to the application thread. */</span></span><br><span class="line">        err = out_err;</span><br><span class="line">        write_finished = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dontblock) &#123;</span><br><span class="line">        <span class="comment">/* non-blocking write is done on ERR_MEM, set error according</span></span><br><span class="line"><span class="comment">           to partial write or not */</span></span><br><span class="line">        err = (conn-&gt;current_msg-&gt;msg.w.offset == <span class="number">0</span>) ? ERR_WOULDBLOCK : ERR_OK;</span><br><span class="line">        write_finished = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* On errors != ERR_MEM, we don&#x27;t try writing any more but return</span></span><br><span class="line"><span class="comment">         the error to the application thread. */</span></span><br><span class="line">      write_finished = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (write_finished) &#123;</span><br><span class="line">    <span class="comment">/* everything was written: set back connection state</span></span><br><span class="line"><span class="comment">       and back to application task */</span></span><br><span class="line">    <span class="type">sys_sem_t</span> *op_completed_sem = LWIP_API_MSG_SEM(conn-&gt;current_msg);</span><br><span class="line">    conn-&gt;current_msg-&gt;err = err;</span><br><span class="line">    conn-&gt;current_msg = <span class="literal">NULL</span>;</span><br><span class="line">    conn-&gt;state = NETCONN_NONE;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCPIP_CORE_LOCKING</span></span><br><span class="line">    <span class="keyword">if</span> (delayed)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      sys_sem_signal(op_completed_sem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCPIP_CORE_LOCKING</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_MEM;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netconn_close</code> 函数用于主动终止一个 TCP 连接，它通过调用 <code>netconn_apimsg</code> 函数构造一个 API 消息，并且请求内核执行 <code>lwip_netconn_do_close</code> 函数，然后通过 netconn 连接结构的信号量进行同步，内核会完成终止 TCP 连接的全过程，无需我们理会。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">netconn_close_shutdown(<span class="keyword">struct</span> netconn *conn, <span class="type">u8_t</span> how)</span><br><span class="line">&#123;</span><br><span class="line">  API_MSG_VAR_DECLARE(msg);</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line">  LWIP_UNUSED_ARG(how);</span><br><span class="line"></span><br><span class="line">  LWIP_ERROR(<span class="string">&quot;netconn_close: invalid conn&quot;</span>,  (conn != <span class="literal">NULL</span>), <span class="keyword">return</span> ERR_ARG;);</span><br><span class="line"></span><br><span class="line">  API_MSG_VAR_ALLOC(msg);</span><br><span class="line">  API_MSG_VAR_REF(msg).conn = conn;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP</span></span><br><span class="line">  <span class="comment">/* shutting down both ends is the same as closing */</span></span><br><span class="line">  API_MSG_VAR_REF(msg).msg.sd.shut = how;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_SO_SNDTIMEO || LWIP_SO_LINGER</span></span><br><span class="line">  <span class="comment">/* get the time we started, which is later compared to</span></span><br><span class="line"><span class="comment">     sys_now() + conn-&gt;send_timeout */</span></span><br><span class="line">  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */</span></span></span><br><span class="line">  API_MSG_VAR_REF(msg).msg.sd.polls_left =</span><br><span class="line">    ((LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT + TCP_SLOW_INTERVAL - <span class="number">1</span>) / TCP_SLOW_INTERVAL) + <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP */</span></span></span><br><span class="line">  err = netconn_apimsg(lwip_netconn_do_close, &amp;API_MSG_VAR_REF(msg));</span><br><span class="line">  API_MSG_VAR_FREE(msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后让我们来看一下具体的调用流程，以下是在网络上找到的一个例程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"> <span class="title function_">tcpecho_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">netconn</span> *<span class="title">conn</span>, *<span class="title">newconn</span>;</span></span><br><span class="line"> <span class="type">err_t</span> err;</span><br><span class="line"> LWIP_UNUSED_ARG(arg);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Create a new connection identifier. */</span></span><br><span class="line"> <span class="comment">/* Bind connection to well known port number 7. */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> LWIP_IPV6</span></span><br><span class="line"> conn = netconn_new(NETCONN_TCP_IPV6);</span><br><span class="line"> netconn_bind(conn, IP6_ADDR_ANY, LOCAL_PORT);</span><br><span class="line"> <span class="meta">#<span class="keyword">else</span> <span class="comment">/* LWIP_IPV6 */</span></span></span><br><span class="line"> conn = netconn_new(NETCONN_TCP);              (<span class="number">1</span>)</span><br><span class="line"> netconn_bind(conn, IP_ADDR_ANY, LOCAL_PORT);  (<span class="number">2</span>)</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_IPV6 */</span></span></span><br><span class="line"> LWIP_ERROR(<span class="string">&quot;tcpecho: invalid conn&quot;</span>, (conn != <span class="literal">NULL</span>), <span class="keyword">return</span>;);</span><br><span class="line"></span><br><span class="line"> PRINTF(<span class="string">&quot;本地端口号是%d\n\n&quot;</span>,LOCAL_PORT);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Tell connection to go into listening mode. */</span></span><br><span class="line"> netconn_listen(conn);                         (<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Grab new connection. */</span></span><br><span class="line">     err = netconn_accept(conn, &amp;newconn);        (<span class="number">4</span>)</span><br><span class="line">     <span class="comment">/*printf(&quot;accepted new connection %p\n&quot;, newconn);*/</span></span><br><span class="line">     <span class="comment">/* Process the new connection. */</span></span><br><span class="line">     <span class="keyword">if</span> (err == ERR_OK) &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">netbuf</span> *<span class="title">buf</span>;</span></span><br><span class="line">     <span class="type">void</span> *data;</span><br><span class="line">     <span class="type">u16_t</span> len;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> ((err = netconn_recv(newconn, &amp;buf)) == ERR_OK) &#123;(<span class="number">5</span>)</span><br><span class="line">         <span class="comment">/*printf(&quot;Recved\n&quot;);*/</span></span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">             netbuf_data(buf, &amp;data, &amp;len);(<span class="number">6</span>)</span><br><span class="line">             err = netconn_write(newconn, data, len, NETCONN_COPY);(<span class="number">7</span>)</span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">             <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">             PRINTF(<span class="string">&quot;tcpecho: netconn_write: error \&quot;%s\&quot;\n&quot;</span>,lwip_strerr(err));</span><br><span class="line">             &#125;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">         &#125; <span class="keyword">while</span> (netbuf_next(buf) &gt;= <span class="number">0</span>);(<span class="number">8</span>)</span><br><span class="line">         netbuf_delete(buf);             (<span class="number">9</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*printf(&quot;Got EOF, looping\n&quot;);*/</span></span><br><span class="line">     <span class="comment">/* Close connection and discard connection identifier. */</span></span><br><span class="line">     netconn_close(newconn);           (<span class="number">10</span>)</span><br><span class="line">     netconn_delete(newconn);          (<span class="number">11</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">client</span><span class="params">(<span class="type">void</span> *thread_param)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">netconn</span> *<span class="title">conn</span>;</span></span><br><span class="line">     <span class="type">int</span> ret;</span><br><span class="line">     <span class="type">ip4_addr_t</span> ipaddr;</span><br><span class="line">     <span class="type">uint8_t</span> send_buf[]= <span class="string">&quot;This is a TCP Client test...\n&quot;</span>;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">         conn = netconn_new(NETCONN_TCP); (<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">if</span> (conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             PRINT_DEBUG(<span class="string">&quot;create conn failed!\n&quot;</span>);</span><br><span class="line">             vTaskDelay(<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         IP4_ADDR(&amp;ipaddr,DEST_IP_ADDR0,DEST_IP_ADDR1,DEST_IP_ADDR2,DEST_IP_ADDR3); (<span class="number">2</span>)</span><br><span class="line">         ret = netconn_connect(conn,&amp;ipaddr,DEST_PORT); (<span class="number">3</span>)</span><br><span class="line">         <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">             PRINT_DEBUG(<span class="string">&quot;Connect failed!\n&quot;</span>);</span><br><span class="line">             netconn_close(conn); (<span class="number">4</span>)</span><br><span class="line">             vTaskDelay(<span class="number">10</span>);</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         PRINT_DEBUG(<span class="string">&quot;Connect to server successful!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">             ret = netconn_write(conn,send_buf,<span class="keyword">sizeof</span>(send_buf),<span class="number">0</span>); (<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">             vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从以上的代码可以看出，使用 netconn 建立连接的过程很像 socket  的建立过程。实际上，lwip 内的 socket 实现实际上就是对 NETCONN API 提供的方法进行了一层封装。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/10/30/lwip/" title="lwip 源码分析" target="_blank" rel="external">http://example.com/2022/10/30/lwip/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/TenonOS" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/TenonOS" target="_blank"><span class="text-dark">TenonOS</span><small class="ml-1x">unikraft-learning</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/11/07/9pfs%20kvm%20qemu%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B/" title="9pfs kvm qemu源码流程"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/10/30/uknetdev/" title="uknetdev 源码分析"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/TenonOS" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>