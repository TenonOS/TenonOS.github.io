<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Linux系统调用 | TenonOS-unikraft-learning</title>
  <meta name="description" content="Linux系统调用1、系统调用相关概念1、系统调用 系统调用：系统调用是应用程序和内核之间的交互接口，它是由内核提供并且可供用户调用的函数集合。 中断：系统处理异常事件的一种机制，在计算机执行期间系统发生了非预期的异常事件时，当前执行任务被中止并且相应的事件处理程序被执行，在处理完毕后又返回到原来被中断处继续执行。 计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统调用">
<meta property="og:url" content="http://example.com/2022/11/12/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Linux系统调用1、系统调用相关概念1、系统调用 系统调用：系统调用是应用程序和内核之间的交互接口，它是由内核提供并且可供用户调用的函数集合。 中断：系统处理异常事件的一种机制，在计算机执行期间系统发生了非预期的异常事件时，当前执行任务被中止并且相应的事件处理程序被执行，在处理完毕后又返回到原来被中断处继续执行。 计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/unikraft-syscall/os.jpg">
<meta property="og:image" content="http://example.com/images/unikraft-syscall/sys_table.jpg">
<meta property="article:published_time" content="2022-11-12T05:09:27.596Z">
<meta property="article:modified_time" content="2022-11-12T05:08:15.799Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="基础知识">
<meta property="article:tag" content="系统调用">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/unikraft-syscall/os.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2022/11/12/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/TenonOS" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">TenonOS</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">unikraft-learning</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Zhejiang, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/TenonOS" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/KVM%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%8C%96/">KVM与虚拟化</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%85%E5%AD%98/">内存</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8/">文件系统与存储</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">系统调用</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BA%BF%E7%A8%8B/">线程</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a><span class="category-list-count">5</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HPC/" rel="tag">HPC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lib/" rel="tag">Lib</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Plat/" rel="tag">Plat</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Serverless/" rel="tag">Serverless</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" rel="tag">函数调用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%96%E9%83%A8%E5%BA%93/" rel="tag">外部库</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="tag">系统调用</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/HPC/" style="font-size: 13.17px;">HPC</a> <a href="/tags/Lib/" style="font-size: 14px;">Lib</a> <a href="/tags/Plat/" style="font-size: 13.83px;">Plat</a> <a href="/tags/Serverless/" style="font-size: 13.33px;">Serverless</a> <a href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" style="font-size: 13px;">函数调用</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 13.67px;">基础知识</a> <a href="/tags/%E5%A4%96%E9%83%A8%E5%BA%93/" style="font-size: 13.5px;">外部库</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" style="font-size: 13.17px;">系统调用</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">19</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a>
              </p>
              <p class="item-title">
                <a href="/2022/12/13/SIGCOMM22_SPRIGHT/" class="title">SIGCOMM&#39;22 SPRIGHT Extracting the Server from Serverless Computing! High-performance eBPF-based Event-driven, Shared-memory Processing</a>
              </p>
              <p class="item-date">
                <time datetime="2022-12-13T12:26:49.929Z" itemprop="datePublished">2022-12-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a>
              </p>
              <p class="item-title">
                <a href="/2022/12/13/Memory%20Deduplication%20for%20Serverless%20Computing%20with%20Medes/" class="title">EuroSys&#39;22 Memory Deduplication for Serverless Computing with Medes</a>
              </p>
              <p class="item-date">
                <time datetime="2022-12-13T12:26:49.918Z" itemprop="datePublished">2022-12-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a>
              </p>
              <p class="item-title">
                <a href="/2022/12/13/Demikernel/" class="title">SOSP&#39;21 The Demikernel Datapath OS Architecture for Microsecond-scale Datacenter Systems</a>
              </p>
              <p class="item-date">
                <time datetime="2022-12-13T12:26:49.894Z" itemprop="datePublished">2022-12-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a>
              </p>
              <p class="item-title">
                <a href="/2022/12/13/ASPLOS22_Serverless-Computing-on-Heterogeneous-Computers/" class="title">ASPLOS&#39;22 Serverless Computing on Heterogeneous Computers</a>
              </p>
              <p class="item-date">
                <time datetime="2022-12-13T12:26:49.893Z" itemprop="datePublished">2022-12-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a>
              </p>
              <p class="item-title">
                <a href="/2022/12/13/A%20Simpler%20and%20Faster%20NIC%20Driver%20Model%20for%20Network%20Functions/" class="title">OSDI&#39;20 A Simpler and Faster NIC Driver Model for Network Functions</a>
              </p>
              <p class="item-date">
                <time datetime="2022-12-13T12:26:49.891Z" itemprop="datePublished">2022-12-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">Linux系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、系统调用相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">1、系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">2、系统调用的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81API%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E3%80%81POSIX%E6%A0%87%E5%87%86%E5%92%8CC%E5%BA%93"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">3、API、系统调用、POSIX标准和C库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">4、系统调用表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">5、程序访问系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.2.</span> <span class="toc-text">2、系统调用过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0sys-xxx"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">1、响应函数sys_xxx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7-gt-%E6%95%B0%E7%BB%84%E4%B8%8E%E4%B8%8B%E6%A0%87"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">2、系统调用表与系统调用号-&#x3D;&gt;数组与下标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%91%BD%E4%BB%A4%E8%BD%AC%E6%8D%A2%E4%B8%BAINT-0x80%E4%B8%AD%E6%96%AD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">3、进程的系统调用命令转换为INT 0x80中断的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">4、系统调用功能模块的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E4%B8%BA%E5%90%84%E7%A7%8D%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">5、内核如何为各种系统调用服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81ret-from-sys-call"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">6、ret_from_sys_call</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E4%B8%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.2.7.</span> <span class="toc-text">7、内核如何为系统调用的参数传递参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.0.2.7.1.</span> <span class="toc-text">1、参数传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81"><span class="toc-number">1.0.2.7.2.</span> <span class="toc-text">2、参数验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.0.2.7.3.</span> <span class="toc-text">3、系统调用的返回值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.2.8.</span> <span class="toc-text">8、访问系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.0.2.8.1.</span> <span class="toc-text">1、系统调用上下文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AE%BF%E9%97%AE%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.0.2.8.2.</span> <span class="toc-text">2、系统调用访问示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BB%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.2.8.3.</span> <span class="toc-text">3、从用户空间直接访问系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BE%E4%BE%8Bkill-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.3.</span> <span class="toc-text">3、举例kill()系统调用过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Syscall%E6%B5%81%E7%A8%8B"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">2、Syscall流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81SYSCALL-DEFINE"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">3、SYSCALL_DEFINE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.4.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">内核空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">用户空间</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Linux系统调用原理" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Linux系统调用
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/11/12/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/" class="article-date">
	  <time datetime="2022-11-12T05:09:27.596Z" itemprop="datePublished">2022-11-12</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">系统调用</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a>, <a class="article-tag-link-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="tag">系统调用</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/11/12/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="Linux系统调用"><a href="#Linux系统调用" class="headerlink" title="Linux系统调用"></a>Linux系统调用</h1><h3 id="1、系统调用相关概念"><a href="#1、系统调用相关概念" class="headerlink" title="1、系统调用相关概念"></a>1、系统调用相关概念</h3><h4 id="1、系统调用"><a href="#1、系统调用" class="headerlink" title="1、系统调用"></a>1、系统调用</h4><ul>
<li><strong>系统调用</strong>：系统调用是应用程序和内核之间的交互接口，它是由内核提供并且可供用户调用的函数集合。</li>
<li><strong>中断</strong>：系统处理异常事件的一种机制，在计算机执行期间系统发生了非预期的异常事件时，当前执行任务被中止并且相应的事件处理程序被执行，在处理完毕后又返回到原来被中断处继续执行。</li>
<li>计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，为了更好的管理这些资源进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的系统调用（System Call）。</li>
<li><img src="/images/unikraft-syscall/os.jpg" alt="img" style="zoom: 25%;" /></li>
</ul>
<h4 id="2、系统调用的实现"><a href="#2、系统调用的实现" class="headerlink" title="2、系统调用的实现"></a>2、系统调用的实现</h4><ul>
<li>操作系统一般是通过中断从用户态切换到内核态。中断就是一个硬件或软件请求，要求CPU暂停当前的工作，去处理更重要的事情。比如，在x86机器上可以通过int指令进行软件中断，而在磁盘完成读写操作后会向CPU发起硬件中断。</li>
<li>中断有两个重要的属性，中断号和中断处理程序。中断号用来标识不同的中断，不同的中断具有不同的中断处理程序。在操作系统内核中维护着一个中断向量表（Interrupt Vector Table），这个数组存储了所有中断处理程序的地址，而中断号就是相应中断在中断向量表中的偏移量。</li>
<li> 一般地，系统调用都是通过中断实现的.</li>
</ul>
<h4 id="3、API、系统调用、POSIX标准和C库"><a href="#3、API、系统调用、POSIX标准和C库" class="headerlink" title="3、API、系统调用、POSIX标准和C库"></a>3、API、系统调用、POSIX标准和C库</h4><ul>
<li>对于应用编程接口API和系统调用之间的关系，一般来说，应用程序调用用户空间实现的用户编程接口来编程，而不是直接执行系统调用。一个接口函数可以由一个系统调用实现，也可以由多个系统调用实现，甚至不完全使用系统调用。</li>
<li>UNIX系统在设计的早期就出现了操作系统的API层，UNIX的世界中，最通用的的系统调用层接口是POSIX(Portable Operating System Interface of UNIX)标准。需要注意的是，POSIX标准针对的是API而不是系统调用，判断一个系统是否是POSIX兼容时，要看它是否提供一组合适的应用编程接口，而不是看它的系统调用是如何定义和实现的。</li>
<li>Linux操作系统的API通常是以C标准库的方式提供的，比如Linux中的libc库。C标准库提供了POSIX的绝大部分API的实现，同时也为内核提供的每个系统调用封装了相应的函数，并且系统调用和C标准库封装的函数名称通常是相同的。例如，open系统调用在C标准库中对应的函数是open函数。另外，有几个接口函数可能调用封装了不同功能的同一个系统调用，例如libc库中实现的malloc()、calloc()和free()等函数，这几个函数用来分配和释放虚拟内存（堆上的虚拟内存），他们都是利用brk系统调用来实现的。</li>
</ul>
<h4 id="4、系统调用表"><a href="#4、系统调用表" class="headerlink" title="4、系统调用表"></a>4、系统调用表</h4><ul>
<li>Linux中每个系统调用都有相应的系统调用号作为唯一的标识，内核维护一张系统调用表，sys_call_table，表中的元素是系统调用函数的起始地址，而系统调用号就是系统调用在调用表的偏移量。以系统调用号_NR_name作为下标，可找出系统调用表sys_call_table中对应表项的内容，它正好是该系统调用的响应函数sys_name的入口地址。在x86上，系统调用号是通过eax寄存器传递给内核的。</li>
<li>unistd32.h是位于include目录下的Linux标准头文件，此代码文件主要包含：系统调用号、系统调用汇编函数和系统调用函数原型。用户在调用一个系统调用时，系统调用号作为参数传递给终端0X80，该标号实际上是系统调用表sys_call_table的下标，通过该标号执行相应的系统调用。system_call()函数通过将给定的系统调用号与NR_syscalls做比较来检查其有效性。如果它大于或者等于NR syscalls,该函数就返回一ENOSYS。否则，就执行相应的系统调用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是内核实现的系统调用符号常数，用于作为系统调用函数表中的索引值。( arch/arm64/include/asm/unistd32.h )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall 0 </span></span><br><span class="line">__SYSCALL(__NR_restart_syscall, sys_restart_sysycall)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit 1 <span class="comment">//终止进程</span></span></span><br><span class="line">__SYSCALL(__NR_exit, sys_exit)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 2  <span class="comment">//创建一个新进程</span></span></span><br><span class="line">__SYSCALL(__NR_fork, sys_fork)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read 3  <span class="comment">//读文件</span></span></span><br><span class="line">__SYSCALL(__NR_read, sys_read)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 4 <span class="comment">//写文件</span></span></span><br><span class="line">__SYSCALL(__NR_write, sys_write)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open 5  <span class="comment">//打开文件</span></span></span><br><span class="line">__SYSCALL(__NR_open, ccompat_sys_open)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>例如，open这个系统调用被赋予的系统调用号是5，因此在所有的ARM64系统中，open这个系统调用号是不能更改的，open系统调用最终实现在如下函数中：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;fs/open.c&gt;</span><br><span class="line">SYSCALL_DEFINE3(open,<span class="type">const</span> <span class="type">char</span> __user *, filename,<span class="type">int</span> , flagsa,<span class="type">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">        flags |= O_LARGEFILE;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> do_sys_open(AT_FDCED, filename, flags, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SYSCALL_DEFINEx是一类宏，实现在include/linux/syscall.h头文件中。</li>
<li>其中SYSCALL_DEFINE1表示有1个参数，SYSCALL_DEFINE2表示有两个参数，以此类推。SYSCALL_DEFINEx宏的定义如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINEx(x, name, ...)</span></span><br><span class="line">	SYSCALL_METADATA(sname,  x, __VA_ARGS_)</span><br><span class="line">    __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br></pre></td></tr></table></figure>

<ul>
<li>这个宏在扩展完之后会变成sys_open()函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> __arm64_sys_open(<span class="type">const</span> <span class="keyword">struct</span> pt_regs *regs);</span><br><span class="line"></span><br><span class="line">asmlinkage <span class="type">long</span> __arm64_sys_open(<span class="type">const</span> <span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __se_sys_open(filename, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> __se_sys_open(<span class="type">const</span> <span class="type">char</span> __user * filename, <span class="type">int</span> flags, <span class="type">umode_t</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> ret = __do_sys_open(filename, flags, mode);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> __do_sys_open(<span class="type">const</span> <span class="type">char</span> __user *filename, <span class="type">int</span> flags, <span class="type">umode_t</span> mode)</span><br></pre></td></tr></table></figure>

<ul>
<li>因此， SYSCALL_DEFINE3(open, …)语句展开后会多出两个函数，分别是__arm64_sys_open()和__se_sys_open()函数。其中__arm64_sys_open()函数的地址会存放在系统调用表sys_call_table()中，最后这两个函数变成了__do_sys_open()函数。</li>
<li>在kernel/sys.c文件中，__SYSCALL宏用来设置某个系统调用的函数指针到sys_call_table[]数组中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL(nr, sym)  [nr] = (syscall_fn_t)__arm64_##sym,</span></span><br></pre></td></tr></table></figure>

<ul>
<li>系统在初始化时会把__arm64_sys_xx()函数添加到 sys_call_table[]数组中 ，因此，sys_call_table的原型如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">long</span> <span class="params">(*<span class="type">syscall_fn_t</span>)</span> <span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数为pt-regs *regs数据结构，系统调用表如图所示</li>
<li><img src="/images/unikraft-syscall/sys_table.jpg" alt="img"></li>
</ul>
<h4 id="5、程序访问系统调用"><a href="#5、程序访问系统调用" class="headerlink" title="5、程序访问系统调用"></a>5、程序访问系统调用</h4><ul>
<li>通过C标准库函数来访问系统调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;usistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/syscall.h&gt;</span> <span class="comment">/*系统调用的定义&gt;</span></span></span><br><span class="line"><span class="comment"><span class="meta"></span></span></span><br><span class="line"><span class="comment"><span class="meta">long syscall(long number, ...);</span></span></span><br><span class="line"><span class="comment"><span class="meta"></span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>syscall()函数可以直接执行系统调用，第一个参数是系统调用号，比如open系统调用号是5，后面的“…”是可变参数，用来传递参数到内核，如open的调用：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NR_OPEN 5</span></span><br><span class="line">syscall(NR_OPEN, filename, flags, mode);</span><br></pre></td></tr></table></figure>

<h3 id="2、系统调用过程"><a href="#2、系统调用过程" class="headerlink" title="2、系统调用过程"></a>2、系统调用过程</h3><h4 id="1、响应函数sys-xxx"><a href="#1、响应函数sys-xxx" class="headerlink" title="1、响应函数sys_xxx"></a>1、响应函数sys_xxx</h4><p>响应函数名以“sys_”开头，后跟该系统调用的名字。</p>
<blockquote>
<p>例如<br>系统调用fork()的响应函数是sys_fork()(见Kernel/fork.c),<br>exit()的响应函数是sys_exit()(见kernel/fork.)。</p>
</blockquote>
<h4 id="2、系统调用表与系统调用号-gt-数组与下标"><a href="#2、系统调用表与系统调用号-gt-数组与下标" class="headerlink" title="2、系统调用表与系统调用号-=&gt;数组与下标"></a>2、系统调用表与系统调用号-=&gt;数组与下标</h4><ul>
<li><p>上面已经提到，unisted.h为每个系统调用规定了唯一的编号。</p>
</li>
<li><p>假设用name表示系统调用的名称，那么系统调用号与系统调用响应函数的关系是：以系统调用号_NR_name作为下标，可找出系统调用表sys_call_table(见arch/i386/kernel/entry.S)中对应表项的内容，它正好是该系统调用的响应函数sys_name的入口地址。</p>
</li>
<li><p>系统调用表sys_call_table记录了各sys_name函数在表中的位置，共190项。有了这张表，就很容易根据特定系统调用在表中的偏移量，找到对应的系统调用响应函数的入口地址。系统调用表共256项，余下的项是可供用户自己添加的系统调用空间。</p>
</li>
<li><p>在Linux中，每个系统调用被赋予一个系统调用号。这样，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号就被用来指明到底是要执行哪个系统调用。进程不会提及系统调用的名称。</p>
</li>
<li><p>系统调用号相当关键，一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。Linux有一个“未实现”系统调用sys_ni_syscall()，它除了返回一ENOSYS外不做任何其他工作，这个错误号就是专门针对无效的系统调用而设的。</p>
</li>
<li><p>因为所有的系统调用陷入内核的方式都一样，所以仅仅是陷入内核空间是不够的。因此必须把系统调用号一并传给内核。在x86上，系统调用号是通过eax寄存器传递给内核的。在陷人内核之前，用户空间就把相应系统调用所对应的号放入eax中了。这样系统调用处理程序一旦运行，就可以从eax中得到数据。其他体系结构上的实现也都类似。</p>
</li>
<li><p>内核记录了系统调用表中的所有已注册过的系统调用的列表，存储在sys_call_table中。它与体系结构有关，一般在entry.s中定义。这个表中为每一个有效的系统调用指定了惟一的系统调用号。sys_call_table是一张由指向实现各种系统调用的内核函数的函数指针组成的表：<br>system_call()函数通过将给定的系统调用号与NR_syscalls做比较来检查其有效性。如果它大于或者等于NR syscalls,该函数就返回一ENOSYS。否则，就执行相应的系统调用。</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call *sys_ call-table(，%eax, 4)1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于系统调用表中的表项是以32位(4字节)类型存放的，所以内核需要将给定的系统调用号乘以4，然后用所得的结果在该表中查询其位置</p>
</blockquote>
<h4 id="3、进程的系统调用命令转换为INT-0x80中断的过程"><a href="#3、进程的系统调用命令转换为INT-0x80中断的过程" class="headerlink" title="3、进程的系统调用命令转换为INT 0x80中断的过程"></a>3、进程的系统调用命令转换为INT 0x80中断的过程</h4><p>宏定义_syscallN()见include/asm/unisted.h)用于系统调用的格式转换和参数的传递。N取0~5之间的整数。</p>
<p>参数个数为N的系统调用由_syscallN()负责格式转换和参数传递。系统调用号放入EAX寄存器，启动INT 0x80后，规定返回值送EAX寄存器。</p>
<h4 id="4、系统调用功能模块的初始化"><a href="#4、系统调用功能模块的初始化" class="headerlink" title="4、系统调用功能模块的初始化"></a>4、系统调用功能模块的初始化</h4><p>对系统调用的初始化也就是对INT 0x80的初始化。</p>
<p>系统启动时，汇编子程序setup_idt(见arch/i386/kernel/head.S)准备了1张256项的idt表，由start_kernel()(见init/main.c),trap_init()(见arch/i386/kernel/traps.c)调用的C语言宏定义set_system_gate(0x80,&amp;system_call)(见include/asm/system.h)设置0x80号软中断的服务程序为 system_call(见arch/i386/kernel/entry.S), system.call就是所有系统调用的总入口。</p>
<h4 id="5、内核如何为各种系统调用服务"><a href="#5、内核如何为各种系统调用服务" class="headerlink" title="5、内核如何为各种系统调用服务"></a>5、内核如何为各种系统调用服务</h4><p>当进程需要进行系统调用时，必须以C语言函数的形式写一句系统调用命令。该命令如果已在某个头文件中由相应的_syscallN()展开，则用户程序必须包含该文件。当进程执行到用户程序的系统调用命令时，实际上执行了由宏命令_syscallN()展开的函数。系统调用的参数 由各通用寄存器传递，然后执行INT 0x80，以内核态进入入口地址system_call。</p>
<h4 id="6、ret-from-sys-call"><a href="#6、ret-from-sys-call" class="headerlink" title="6、ret_from_sys_call"></a>6、ret_from_sys_call</h4><p>以ret_from_sys_call入口的汇编程序段在linux进程管理中起到了十分重要的作用。</p>
<p>所有系统调用结束前以及大部分中断服务返回前，都会跳转至此处入口地址。 该段程序不仅仅为系统调用服务，它还处理中断嵌套、CPU调度、信号等事务。</p>
<h4 id="7、内核如何为系统调用的参数传递参数"><a href="#7、内核如何为系统调用的参数传递参数" class="headerlink" title="7、内核如何为系统调用的参数传递参数"></a>7、内核如何为系统调用的参数传递参数</h4><h5 id="1、参数传递"><a href="#1、参数传递" class="headerlink" title="1、参数传递"></a>1、参数传递</h5><p>除了系统调用号以外，大部分系统调用都还需要一些外部的参数输人。所以，在发生异常的时候，应该把这些参数从用户空间传给内核。最简单的办法就是像传递系统调用号一样把这些参数也存放在寄存器里。在x86系统上，ebx, ecx, edx, esi和edi按照顺序存放前五个参数。需要六个或六个以上参数的情况不多见，此时，应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。</p>
<p>给用户空间的返回值也通过寄存器传递。在x86系统上，它存放在eax寄存器中。接下来许多关于系统调用处理程序的描述都是针对x86版本的。但不用担心，所有体系结构的实现都很类似。</p>
<h5 id="2、参数验证"><a href="#2、参数验证" class="headerlink" title="2、参数验证"></a>2、参数验证</h5><p>系统调用必须仔细检查它们所有的参数是否合法有效。举例来说，与文件I/O相关的系统调用必须检查文件描述符是否有效。与进程相关的函数必须检查提供的PID是否有效。必须检查每个参数，保证它们不但合法有效，而且正确。</p>
<p>最重要的一种检查就是检查用户提供的指针是否有效。试想，如果一个进程可以给内核传递指针而又无须被检查，那么它就可以给出一个它根本就没有访问权限的指针，哄骗内核去为它拷贝本不允许它访问的数据，如原本属于其他进程的数据。在接收一个用户空间的指针之前，内核必须保证：</p>
<ul>
<li>指针指向的内存区域属于用户空间。进程决不能哄骗内核去读内核空间的数据。</li>
<li>指针指向的内存区域在进程的地址空间里。进程决不能哄骗内核去读其他进程的数据。</li>
<li>如果是读，该内存应被标记为可读。如果是写，该内存应被标记为可写。进程决不能绕过内存访问限制。</li>
</ul>
<p>内核提供了两个方法来完成必须的检查和内核空间与用户空间之间数据的来回拷贝。注意，内核无论何时都不能轻率地接受来自用户空间的指针!这两个方法中必须有一个被调用。为了向用户空间写入数据，内核提供了copy_to_user()，它需要三个参数。第一个参数是进程空间中的目的内存地址。第二个是内核空间内的源地址。最后一个参数是需要拷贝的数据长度(字节数)。</p>
<p>为了从用户空间读取数据，内核提供了copy_from_ user()，它和copy-to-User()相似。该函数把第二个参数指定的位置上的数据拷贝到第一个参数指定的位置上，拷贝的数据长度由第三个参数决定。</p>
<p>如果执行失败，这两个函数返回的都是没能完成拷贝的数据的字节数。如果成功，返回0。当出现上述错误时，系统调用返回标准-EFAULT。</p>
<p>注意copy_to_user()和copy_from_user()都有可能引起阻塞。当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候，这种情况就会发生。此时，进程就会休眠，直到缺页处理程序将该页从硬盘重新换回物理内存。</p>
<h5 id="3、系统调用的返回值"><a href="#3、系统调用的返回值" class="headerlink" title="3、系统调用的返回值"></a>3、系统调用的返回值</h5><p>系统调用(在Linux中常称作syscalls)通常通过函数进行调用。它们通常都需要定义一个或几个参数(输入)而且可能产生一些副作用，例如写某个文件或向给定的指针拷贝数据等等。为防止和正常的返回值混淆，系统调用并不直接返回错误码，而是将错误码放入一个名为errno的全局变量中。通常用一个负的返回值来表明错误。返回一个0值通常表明成功。如果一个系统调用失败，你可以读出errno的值来确定问题所在。通过调用perror()库函数，可以把该变量翻译成用户可以理解的错误字符串。</p>
<p>errno不同数值所代表的错误消息定义在errno.h中，你也可以通过命令”man 3 errno”来察看它们。需要注意的是，errno的值只在函数发生错误时设置，如果函数不发生错误，errno的值就无定义，并不会被置为0。另外，在处理errno前最好先把它的值存入另一个变量，因为在错误处理过程中，即使像printf()这样的函数出错时也会改变errno的值。</p>
<p>当然，系统调用最终具有一种明确的操作。举例来说，如getpid()系统调用，根据定义它会返回当前进程的PID。内核中它的实现非常简单:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_ getpid(void)</span><br><span class="line">&#123;</span><br><span class="line">    return current-&gt; tgid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的系统调用尽管非常简单，但我们还是可以从中发现两个特别之处。首先，注意函数声明中的asmlinkage限定词，这是一个小戏法，用于通知编译器仅从栈中提取该函数的参数。所有的系统调用都需要这个限定词。其次，注意系统调用get_pid()在内核中被定义成sys_ getpid。这是Linux中所有系统调用都应该遵守的命名规则。</p>
<h4 id="8、访问系统调用"><a href="#8、访问系统调用" class="headerlink" title="8、访问系统调用"></a>8、访问系统调用</h4><h5 id="1、系统调用上下文"><a href="#1、系统调用上下文" class="headerlink" title="1、系统调用上下文"></a>1、系统调用上下文</h5><p>内核在执行系统调用的时候处于进程上下文。current指针指向当前任务，即引发系统调用的那个进程。</p>
<p>在进程上下文中，内核可以休眠并且可以被抢占。这两点都很重要。首先，能够休眠说明系统调用可以使用内核提供的绝大部分功能。休眠的能力会给内核编程带来极大便利。在进程上下文中能够被抢占，其实表明，像用户空间内的进程一样，当前的进程同样可以被其他进程抢占。因为新的进程可以使用相同的系统调用，所以必须小心，保证该系统调用是可重人的。当然，这也是在对称多处理中必须同样关心的问题。</p>
<p>当系统调用返回的时候，控制权仍然在system_call()中，它最终会负责切换到用户空间并让用户进程继续执行下去。</p>
<h5 id="2、系统调用访问示例"><a href="#2、系统调用访问示例" class="headerlink" title="2、系统调用访问示例"></a>2、系统调用访问示例</h5><p>操作系统使用系统调用表将系统调用编号翻译为特定的系统调用。系统调用表包含有实现每个系统调用的函数的地址。例如，read() 系统调用函数名为sys_read。read()系统调用编号是 3，所以sys_read() 位于系统调用表的第四个条目中（因为系统调用起始编号为0）。从地址 sys_call_table + (3 * word_size) 读取数据，得到sys_read()的地址。</p>
<p>找到正确的系统调用地址后，它将控制权转交给那个系统调用。我们来看定义sys_read()的位置，即fs/read_write.c文件。这个函数会找到关联到 fd 编号（传递给 read() 函数的）的文件结构体。那个结构体包含指向用来读取特定类型文件数据的函数的指针。进行一些检查后，它调用与文件相关的 read() 函数，来真正从文件中读取数据并返回。与文件相关的函数是在其他地方定义的 —— 比如套接字代码、文件系统代码，或者设备驱动程序代码。这是特定内核子系统最终与内核其他部分协作的一个方面。</p>
<p>读取函数结束后，从sys_read()返回，它将控制权切换给 ret_from_sys。它会去检查那些在切换回用户空间之前需要完成的任务。如果没有需要做的事情，那么就恢复用户进程的状态，并将控制权交还给用户程序。</p>
<h5 id="3、从用户空间直接访问系统调用"><a href="#3、从用户空间直接访问系统调用" class="headerlink" title="3、从用户空间直接访问系统调用"></a>3、从用户空间直接访问系统调用</h5><p>通常，系统调用靠C库支持。用户程序通过包含标准头文件并和C库链接，就可以使用系统调用(或者调用库函数，再由库函数实际调用)。但如果你仅仅写出系统调用，glibc库恐怕并不提供支持。值得庆幸的是，Linux本身提供了一组宏，用于直接对系统调用进行访问。它会设置好寄存器并调用陷人指令。这些宏是_syscalln()，其中n的范围从0到6。代表需要传递给系统调用的参数个数，这是由于该宏必须了解到底有多少参数按照什么次序压入寄存器。举个例子，open()系统调用的定义是:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long open(const char *filename, int flags, int mode)</span><br></pre></td></tr></table></figure>

<p>而不靠库支持，直接调用此系统调用的宏的形式为:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define NR_ open 5</span><br><span class="line">syscall3(long, open, const char*，filename, int, flags, int, mode)</span><br></pre></td></tr></table></figure>

<p>这样，应用程序就可以直接使用open()<br>对于每个宏来说，都有2+ n个参数。<br>第一个参数对应着系统调用的返回值类型。<br>第二个参数是系统调用的名称。再以后是按照系统调用参数的顺序排列的每个参数的类型和名称。<br><em>NR</em> open在&lt;asm/unistd.h&gt;中定义，是系统调用号。该宏会被扩展成为内嵌汇编的C函数。由汇编语言执行前一节所讨论的步骤，将系统调用号和参数压入寄存器并触发软中断来陷入内核。调用open()系统调用直接把上面的宏放置在应用程序中就可以了。</p>
<h3 id="3、举例kill-系统调用过程"><a href="#3、举例kill-系统调用过程" class="headerlink" title="3、举例kill()系统调用过程"></a>3、举例kill()系统调用过程</h3><ul>
<li>这里以文章<a target="_blank" rel="noopener" href="http://gityuan.com/2016/04/16/kill-signal/">理解杀进程的实现原理</a>中的kill()方法为例子，来找一找kill()方法系统调用的过程。</li>
</ul>
<p><strong>Tips 1：</strong> 用户空间的方法<code>xxx</code>，对应系统调用层方法则是<code>sys_xxx</code>；<br><strong>Tips 2：</strong> <code>unistd.h</code>文件记录着系统调用中断号的信息。</p>
<ul>
<li>故用户空间<code>kill</code>方法则对应系统调用层便是<code>sys_kill</code>，这个方法去哪里找呢？从<code>/kernel/include/uapi/asm-generic/unistd.h</code>等还有很多<code>unistd.h</code>去慢慢查看，查看关键字<code>sys_kill</code>，便能看到下面几行：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* kernel/signal.c */</span><br><span class="line">__SYSCALL(__NR_kill, sys_kill)</span><br></pre></td></tr></table></figure>

<ul>
<li>根据这个能得到一丝线索，那就是kill对应的方法sys_kill位于<code>/kernel/signal.c</code>文件。</li>
</ul>
<p><strong>Tips 3：</strong> 宏定义SYSCALL_DEFINEx(xxx,…)，展开后对应的方法则是<code>sys_xxx</code>；<br><strong>Tips 4：</strong> 方法参数的个数x，对应于SYSCALL_DEFINEx。</p>
<p><code>kill(int pid, int sig)</code>方法共两个参数，则对应方法于<code>SYSCALL_DEFINE2(kill,...)</code>，进入signal.c文件，再次搜索关键字，便能看到方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)</span><br><span class="line">&#123;</span><br><span class="line">    struct siginfo info;</span><br><span class="line">    info.si_signo = sig;</span><br><span class="line">    info.si_errno = 0;</span><br><span class="line">    info.si_code = SI_USER;</span><br><span class="line">    info.si_pid = task_tgid_vnr(current);</span><br><span class="line">    info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line">    return kill_something_info(sig, &amp;info, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)</code> 基本等价于 <code>asmlinkage long sys_kill(int pid, int sig)</code>，这里用的是基本等价，往下看会解释原因。</p>
<h4 id="2、Syscall流程"><a href="#2、Syscall流程" class="headerlink" title="2、Syscall流程"></a>2、Syscall流程</h4><ul>
<li>Syscall是通过中断方式实现的，ARM平台上通过swi中断来实现系统调用，实现从用户态切换到内核态，发送软中断swi时，从中断向量表中查看跳转代码，其中异常向量表定义在文件/kernelarch/arm/kernel/entry-armv.S(汇编语言文件)。当执行系统调用时会根据系统调用号从系统调用表中来查看目标函数的入口地址，在calls.S文件中声明了入口地址信息。</li>
</ul>
<p><strong>总体流程：</strong>kill() -&gt; kill.S -&gt; swi陷入内核态 -&gt; 从sys_call_table查看到sys_kill -&gt; ret_fast_syscall -&gt; 回到用户态执行kill()下一行代码。 下面介绍部分核心流程：</p>
<ul>
<li><p> 用户程序通过软中断swi指令切入内核态，执行vector_swi处的指令。<code>vector_swi</code>在文件<code>/kenel/arch/arm/kernel/entry-common.S</code>中定义，此处省略。像每一个异常处理程序一样，要做的第一件事当然就是保护现场了。紧接着是获得系统调用的系统调用号</p>
</li>
<li><p>仍以kill()函数为例，来详细说说Syscall调用流程，用户空间kill()定义位于文件<code>kill.S</code>。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;private/bionic_asm.h&gt;</span><br><span class="line">ENTRY(kill)</span><br><span class="line">    mov     ip, r7</span><br><span class="line">    ldr     r7, =__NR_kill</span><br><span class="line">    swi     #0</span><br><span class="line">    mov     r7, ip</span><br><span class="line">    cmn     r0, #(MAX_ERRNO + 1)</span><br><span class="line">    bxls    lr</span><br><span class="line">    neg     r0, r0</span><br><span class="line">    b       __set_errno_internal</span><br><span class="line">END(kill)</span><br></pre></td></tr></table></figure>

<p>当调用kill时, 系统先保存r7内容, 然后将__NR_kill值放入r7, 再执行swi软中断指令切换进内核态。</p>
<ul>
<li> kill的系统调用号为__NR_kill：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_kill (__NR_SYSCALL_BASE + 37)</span><br></pre></td></tr></table></figure>

<p>其中__NR_SYSCALL_BASE=0，也就是__NR_kill系统调用号=37。</p>
<ul>
<li>查看系统调用表，定义在文件<code>/kernel/arch/arm/kernel/calls.S</code>，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 35 */    CALL(sys_ni_syscall)        /* was sys_ftime */</span><br><span class="line">            CALL(sys_sync)</span><br><span class="line">            CALL(sys_kill)  //此处为37号</span><br><span class="line">            CALL(sys_rename)</span><br><span class="line">            CALL(sys_mkdir)</span><br></pre></td></tr></table></figure>

<p>到这里可知37号系统调用对应sys_kill()，该方法所对应的函数声明在syscalls.h文件</p>
<ul>
<li>文件<code>/kernel/include/linux/syscalls.h</code>中有如下声明：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_kill(int pid, int sig);</span><br></pre></td></tr></table></figure>

<p>asmlinkage是gcc标签，代表函数读取的参数来自于栈中，而非寄存器。</p>
<h4 id="3、SYSCALL-DEFINE"><a href="#3、SYSCALL-DEFINE" class="headerlink" title="3、SYSCALL_DEFINE"></a>3、SYSCALL_DEFINE</h4><p>sys_kill()定义在内核源码找不到直接定义，而是通过<code>syscalls.h</code>文件中的SYSCALL_DEFINE宏定义。前面已经讲过sys_kill是通过语句<code>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)</code>来定义，下面来一层层剖开，这条宏定义的真面目：</p>
<p><strong>等价 1：</strong></p>
<p><code>syscalls.h</code>中有大量如下宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE0(sname)                    \</span></span><br><span class="line"><span class="meta">    SYSCALL_METADATA(_##sname, 0);                \</span></span><br><span class="line"><span class="meta">    asmlinkage long sys_##sname(void)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<p>可得出原语句等价：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINEx(2, _kill, pid_t, pid, int, sig)</span><br></pre></td></tr></table></figure>

<ul>
<li>注意函数声明中的asmlinkage限定词，这是一个小戏法，用于通知编译器仅从栈中提取该函数的参数。所有的系统调用都需要这个限定词</li>
</ul>
<p>等价 2：**</p>
<p><code>syscalls.h</code>中有如下宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SYSCALL_DEFINEx(x, sname, ...) \</span><br><span class="line">    SYSCALL_METADATA(sname, x, __VA_ARGS__)            \</span><br><span class="line">    __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br></pre></td></tr></table></figure>

<p>可得出原语句等价：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_METADATA(_kill, 2, pid_t, pid, int, sig)</span><br><span class="line">__SYSCALL_DEFINEx(2, _kill, pid_t, pid, int, sig)</span><br></pre></td></tr></table></figure>

<p>define __SYSCALL_DEFINEx(x, name, …)</p>
<p><strong>等价 3：</strong></p>
<p><code>syscalls.h</code>中有如下宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)                    \</span></span><br><span class="line"><span class="meta">  asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))    \</span></span><br><span class="line"><span class="meta">      __attribute__((alias(__stringify(SyS##name))));        \</span></span><br><span class="line"><span class="meta">  static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__));    \</span></span><br><span class="line"><span class="meta">  asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__));    \</span></span><br><span class="line"><span class="meta">  asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__))    \</span></span><br><span class="line"><span class="meta">  &#123;                                \</span></span><br><span class="line"><span class="meta">      long ret = SYSC##name(__MAP(x,__SC_CAST,__VA_ARGS__));    \</span></span><br><span class="line"><span class="meta">      __MAP(x,__SC_TEST,__VA_ARGS__);                \</span></span><br><span class="line"><span class="meta">      __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));    \</span></span><br><span class="line"><span class="meta">      return ret;                        \</span></span><br><span class="line"><span class="meta">  &#125;                                \</span></span><br><span class="line"><span class="meta">  static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__))</span></span><br></pre></td></tr></table></figure>

<p>可得出原语句等价：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_kill(__MAP(2,__SC_DECL,__VA_ARGS__)) \ __attribute__((alias(__stringify(SyS_kill))));        \</span><br><span class="line">static inline long SYSC_kill(__MAP(2,__SC_DECL,__VA_ARGS__));    \</span><br><span class="line">asmlinkage long SyS_kill(__MAP(2,__SC_LONG,__VA_ARGS__));    \</span><br><span class="line">asmlinkage long SyS_kill(__MAP(2,__SC_LONG,__VA_ARGS__)) \ &#123;                                \</span><br><span class="line">    long ret = SYSC_kill(__MAP(2,__SC_CAST,__VA_ARGS__));    \</span><br><span class="line">    __MAP(2,__SC_TEST,__VA_ARGS__);                \</span><br><span class="line">    __PROTECT(2, ret,__MAP(2,__SC_ARGS,__VA_ARGS__));    \</span><br><span class="line">    return ret;                        \</span><br><span class="line">&#125;                                \</span><br><span class="line">static inline long SYSC_kill(__MAP(2,__SC_DECL,__VA_ARGS__))</span><br></pre></td></tr></table></figure>

<p>这里<code>__VA_ARGS__</code>等于 <code>pid_t, pid, int, sig</code>。</p>
<p><strong>等价 4:</strong></p>
<p>先说说这里涉及的宏定义</p>
<p>__MAP宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define __MAP0(m,...)</span><br><span class="line">#define __MAP1(m,t,a) m(t,a)</span><br><span class="line">#define __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)</span><br><span class="line">#define __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)</span><br><span class="line">#define __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)</span><br><span class="line">#define __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)</span><br><span class="line">#define __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)</span><br><span class="line">#define __MAP(n,...) __MAP##n(__VA_ARGS__)</span><br></pre></td></tr></table></figure>

<p>相关宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define __SC_DECL(t, a) t a</span><br><span class="line">#define __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a</span><br><span class="line">#define __SC_CAST(t, a) (t) a</span><br><span class="line">#define __SC_ARGS(t, a) a</span><br><span class="line">#define __SC_TEST(t, a) (void)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(t) &amp;&amp; sizeof(t) &gt; sizeof(long))</span><br></pre></td></tr></table></figure>

<p>展开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__MAP(2,__SC_DECL, pid_t, pid, int, sig) //等价于 pid_t pid, int sig</span><br><span class="line">__MAP(2,__SC_LONG,__VA_ARGS__) //等价于 long pid, long sig</span><br><span class="line">__MAP(2,__SC_CAST,__VA_ARGS__) //等价于 (pid_t) pid, (int)sig</span><br><span class="line">__MAP(2,__SC_ARGS,__VA_ARGS__) //等价于 pid, sig</span><br></pre></td></tr></table></figure>

<p>可得出原语句等价：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//函数声明sys_kill()，并别名指向SyS_kill</span><br><span class="line">asmlinkage long sys_kill(pid_t pid, int sig) __attribute__((alias(__stringify(SyS_kill))));</span><br><span class="line">static inline long SYSC_kill(pid_t pid, int sig);</span><br><span class="line"></span><br><span class="line">//函数声明SyS_kill()</span><br><span class="line">asmlinkage long SyS_kill(long pid, long sig);</span><br><span class="line">asmlinkage long SyS_kill(long pid, long sig)</span><br><span class="line">&#123;</span><br><span class="line">    long ret = SYSC_kill((pid_t) pid, (int)sig);</span><br><span class="line">    BUILD_BUG_ON_ZERO(sizeof(pid_t) &gt; sizeof(long));</span><br><span class="line">    BUILD_BUG_ON_ZERO(sizeof(int) &gt; sizeof(long));</span><br><span class="line">    __PROTECT(2, ret, pid, sig);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">static inline long SYSC_kill(pid_t pid, int sig)</span><br></pre></td></tr></table></figure>

<p>通过以上分析过程：</p>
<ul>
<li>kill添加了<code>sys_</code>前缀，声明sys_kill()函数；</li>
<li>定义SYSC_kill()函数和SyS_kill()函数；</li>
<li>sys_kill，通过别名机制等同于SyS_kill().</li>
</ul>
<p>看到这或许很多人会觉得诧异，为何要如此复杂呢，后来查资料，发现这是由于之前64位Linux存在<code>CVE-2009-2009</code>的漏洞，简单说就是32位参数存放在64位寄存器，修改符号扩展可能导致产生一个非法内存地址，从而导致系统崩溃或者提升权限。 为了修复这个问题，把寄存器高位清零即可，但做起来比较困难，为了做尽可能少的修改，将调用参数统一采用使用long型来接收，再强转为相应参数。 窥见一斑，可见Linux大师们精湛的宏定义，已经用得出神入化。</p>
<p>如果觉得很复杂，那么可以忽略这个宏定义，只要记住<code>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)</code> 基本等价于 <code>asmlinkage long sys_kill(int pid, int sig)</code> 就足够了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h4><ol>
<li>系统调用的函数原型的指针：位于文件/kernel/arch/arm/kernel/calls.S，格式为<code>CALL(sys_xxx)</code>，指定了目标函数的入口地址。</li>
<li>系统调用号的宏定义：位于文件/kernel/arch/arm/include/Uapi/asm/unistd.h，记录着<strong>内核空间的系统调用号</strong>，格式为<code>#define__NR_xxx (__NR_SYSCALL_BASE+[num])</code></li>
<li>系统调用的函数声明：位于文件/kernel/include/linux/syscalls.h，格式为<code>asmlinkage long sys_xxx(args ...);</code></li>
<li>系统调用的函数实现：不同函数位于不同文件，比如kill()位于/kernel/kernel/signal.c文件，格式为<code>SYSCALL_DEFINEx(x, sname, ...)</code></li>
</ol>
<p>前面这4步都是在内核空间相关的文件定义，有了这些，那么内核就可以使用相应的系统调用号。</p>
<h4 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h4><ol>
<li><p>系统调用号的宏定义：位于文件unistd.h，记录着<strong>用户空间的系统调用号</strong>，格式为<code>#define__NR_xxx (__NR_SYSCALL_BASE+[num])</code>。这个文件就是由内核空间同名的头文件自动生成的，所以该文件与内核空间的系统调用号是完全一致。</p>
</li>
<li><p>汇编定义相关函数的中断调用过程：位于文件/bionic/libc/arch-arm/syscalls/xxx.S，比如kill()位于kill.S，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(xxx)</span><br><span class="line">    mov     ip, r7</span><br><span class="line">    ldr     r7, =__NR_xxx</span><br><span class="line">    swi     #0</span><br><span class="line">    mov     r7, ip</span><br><span class="line">    cmn     r0, #(MAX_ERRNO + 1)</span><br><span class="line">    bxls    lr</span><br><span class="line">    neg     r0, r0</span><br><span class="line">    b       __set_errno_internal</span><br><span class="line">END(xxx)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当然kill()方法还有函数声明，有了这些，用户空间也能在程序中使用系统调用。<br>参考如下：</p>
<p>1、CSDN博主「chosen0ne」的原创文章，原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chosen0ne/article/details/7721550">https://blog.csdn.net/chosen0ne/article/details/7721550</a></p>
<p>2、<a target="_blank" rel="noopener" href="http://gityuan.com/2016/05/21/syscall/#%E4%B8%89syscall%E6%B5%81%E7%A8%8B">http://gityuan.com/2016/05/21/syscall/#%E4%B8%89syscall%E6%B5%81%E7%A8%8B</a></p>
<p>3、《奔跑吧 Linux内核》 笨叔 陈悦 著</p>
<p>4、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/267353577">https://zhuanlan.zhihu.com/p/267353577</a></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/11/12/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/" title="Linux系统调用" target="_blank" rel="external">http://example.com/2022/11/12/Linux系统调用原理/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/TenonOS" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/TenonOS" target="_blank"><span class="text-dark">TenonOS</span><small class="ml-1x">unikraft-learning</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/11/12/ukblkdev/" title="ukblkdev源码阅读"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/11/12/DPDK%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="DPDK 基础知识"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/TenonOS" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="/null" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>